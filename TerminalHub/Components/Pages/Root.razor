@page "/multisession"
@page "/"
@using TerminalHub.Components.Shared
@using TerminalHub.Components.Shared.Dialogs
@using TerminalHub.Constants
@using TerminalHub.Models
@using TerminalHub.Services
@using TerminalHub.Analyzers
@using Microsoft.JSInterop
@using Microsoft.Extensions.Configuration
@using Microsoft.Extensions.Logging
@inject ISessionManager SessionManager
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorageService
@inject IConfiguration Configuration
@inject INotificationService NotificationService
@inject IOutputAnalyzerFactory AnalyzerFactory
@inject IGitService GitService
@inject ITerminalService TerminalService
@inject IOutputAnalyzerService OutputAnalyzerService
@inject IInputHistoryService InputHistoryService
@inject IPackageJsonService PackageJsonService
@inject IConPtyService ConPtyService
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>マルチセッション ターミナル</PageTitle>

<Toast @ref="toast" />
<SessionCreateDialog IsVisible="showCreateDialog" 
                    OnSessionCreate="OnSessionCreate" 
                    OnCancel="OnDialogCancel" />
<DevWindow @bind-IsVisible="showDevWindow" />
<SettingsDialog @bind-IsVisible="showSettingsDialog" />
<SubSessionDialog IsVisible="showSubSessionDialog" 
                         ParentSessionName="@subSessionParentSessionName"
                         ParentSessionId="@subSessionParentSessionId"
                         ParentSessionPath="@subSessionParentSessionPath"
                         IsGitRepository="@subSessionParentSessionIsGitRepository"
                         OnSubSessionOperation="OnSubSessionOperation" 
                         OnCancel="() => showSubSessionDialog = false" />
<SessionSettingsDialog IsVisible="showSessionSettingsDialog"
                       SessionId="@settingsSessionId"
                       OnSettingsSaved="OnSessionSettingsSaved"
                       OnCancel="() => showSessionSettingsDialog = false" />

<div class="container-fluid h-100">
    <div class="row h-100">
        <SessionList Sessions=@sessions
                     ActiveSessionId=@activeSessionId
                     IsAddingSession=@isAddingSession
                     EditingMemoSessionId=@editingMemoSessionId
                     TempMemoText=@tempMemoText
                     OnAddSession="AddSession"
                     OnSessionSelect="async (sessionId) => await SelectSession(sessionId)"
                     OnSessionRemove="async (sessionId) => await RemoveSession(sessionId)"
                     OnMemoInput="(text) => tempMemoText = text"
                     OnMemoSave="SaveMemo"
                     OnMemoKeyDown="HandleMemoKeyDown"
                     OnMemoEdit="StartEditingMemo"
                     OnSettingsClick="ShowSettings"
                     OnCreateWorktree="ShowWorktreeDialog"
                     OnSessionSettings="ShowSessionSettingsDialog"
                     OnGitStatusRefresh="RefreshGitStatus"
                     OnSessionExpandedChanged="HandleSessionExpandedChanged" />

        <div class="col-md-9 p-0 position-relative" style="height: 100vh; display: flex; flex-direction: column;">
            @if (activeSessionId != null)
            {
                <!-- ターミナル部分 (70%) -->
                <div style="height: 70%; overflow: hidden;">
                    <div class="terminal-wrapper h-100">
                        @foreach (var session in sessions)
                        {
                            <div id="terminal-@session.SessionId" class="terminal-container" 
                                 style="display: @(session.SessionId == activeSessionId ? "block" : "none");"></div>
                        }
                    </div>
                </div>
                
                <!-- WebUI部分 (30%) -->
                <div style="height: 30%; border-top: 1px solid #dee2e6; background-color: #f8f9fa; display: flex; flex-direction: column;">
                    @{
                        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
                    }
                    @if (currentSession != null)
                    {
                        <!-- タブヘッダー -->
                        <ul class="nav nav-tabs px-3 pt-2" style="flex-shrink: 0;">
                            <li class="nav-item">
                                <a class="nav-link @(bottomPanelTab == BottomPanelTab.TextInput ? "active" : "")" 
                                   href="#" 
                                   @onclick:preventDefault="true"
                                   @onclick="() => bottomPanelTab = BottomPanelTab.TextInput">
                                    <i class="bi bi-chat-left-text"></i> テキスト入力
                                </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link @(bottomPanelTab == BottomPanelTab.DosTerminal ? "active" : "")" 
                                   href="#" 
                                   @onclick:preventDefault="true"
                                   @onclick="async () => await SwitchBottomPanelTab(BottomPanelTab.DosTerminal)">
                                    <i class="bi bi-terminal"></i> DOSターミナル
                                </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link @(bottomPanelTab == BottomPanelTab.TaskRunner ? "active" : "")" 
                                   href="#" 
                                   @onclick:preventDefault="true"
                                   @onclick="async () => await SwitchBottomPanelTab(BottomPanelTab.TaskRunner)">
                                    <i class="bi bi-play-circle"></i> タスクランナー
                                </a>
                            </li>
                        </ul>
                        
                        <!-- タブコンテンツ -->
                        <div class="flex-grow-1" style="overflow-y: auto;">
                            @if (bottomPanelTab == BottomPanelTab.TextInput)
                            {
                                <div class="p-3 h-100 d-flex flex-column">
                                    <div class="flex-grow-1 d-flex flex-column">
                                        <textarea id="inputText" 
                                          class="form-control flex-grow-1" 
                                          data-input-area
                                          @bind="inputText"
                                          @bind:event="oninput"
                                          @onkeydown="OnTextAreaKeyDown"
                                          @onkeydown:preventDefault="@shouldPreventDefault"
                                          placeholder="@(GetPlaceholderText(currentSession.TerminalType))"
                                          style="resize: none; font-family: 'Consolas', 'Monaco', monospace;">
                                </textarea>
                                
                                <div class="mt-2 d-flex justify-content-between align-items-center">
                                    <div class="d-flex align-items-center gap-3">
                                        <div>
                                            <kbd>Enter</kbd> で送信 | <kbd>Shift+Enter</kbd> で改行 | <kbd>Ctrl+↑↓</kbd> で履歴
                                        </div>
                                        @* タスク実行ドロップダウンを一時的に無効化
                                        @if (checkedScripts.Count > 0 && npmScripts != null)
                                        {
                                            <div class="dropdown">
                                                <button class="btn btn-success btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                                    <i class="bi bi-play-fill"></i> タスク実行 (@checkedScripts.Count)
                                                </button>
                                                <ul class="dropdown-menu">
                                                    @foreach (var scriptName in checkedScripts.OrderBy(s => s))
                                                    {
                                                        @if (npmScripts.ContainsKey(scriptName))
                                                        {
                                                            <li>
                                                                <button class="dropdown-item @(runningScripts.Contains(scriptName) ? "disabled" : "")" 
                                                                        @onclick="() => OnTaskButtonClick(scriptName)"
                                                                        disabled="@runningScripts.Contains(scriptName)">
                                                                    @if (runningScripts.Contains(scriptName))
                                                                    {
                                                                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                                                                    }
                                                                    <strong>@scriptName</strong>
                                                                    <div class="small text-muted">@npmScripts[scriptName]</div>
                                                                </button>
                                                            </li>
                                                        }
                                                    }
                                                </ul>
                                            </div>
                                        }
                                        *@
                                    </div>
                                    <div class="btn-group">
                                        <button class="btn btn-secondary @(isCtrlCPressed ? "active" : "")" 
                                                @onclick="SendCtrlC" 
                                                title="強制中断 (Ctrl+C)"
                                                style="@(isCtrlCPressed ? "transform: scale(0.95);" : "")">
                                            <i class="bi bi-x-octagon"></i> Ctrl+C
                                        </button>
                                        <button class="btn btn-secondary @(isEscapePressed ? "active" : "")" 
                                                @onclick="SendEscape" 
                                                title="中断 (Esc)"
                                                style="@(isEscapePressed ? "transform: scale(0.95);" : "")">
                                            <i class="bi bi-stop-circle"></i> Esc
                                        </button>
                                        @if (currentSession.TerminalType == TerminalType.ClaudeCode)
                                        {
                                            <button class="btn btn-secondary @(isModeSwitchPressed ? "active" : "")" 
                                                    @onclick="SendModeSwitch" 
                                                    title="モード切替 (Alt+M)"
                                                    style="@(isModeSwitchPressed ? "transform: scale(0.95);" : "")">
                                                <i class="bi bi-arrow-repeat"></i> Alt+M
                                            </button>
                                        }
                                        @if (showDevButton)
                                        {
                                            <button class="btn btn-secondary" 
                                                    @onclick="() => showDevWindow = !showDevWindow" 
                                                    title="開発ツール">
                                                <i class="bi bi-code-square"></i> Dev
                                            </button>
                                        }
                                        <button class="btn btn-primary" @onclick="SendInput">
                                            <i class="bi bi-send"></i> 送信
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                            }
                            else if (bottomPanelTab == BottomPanelTab.DosTerminal)
                            {
                                <div class="h-100" id="dos-terminal-container" style="background-color: #000; width: 100%; height: 100%;">
                                    <!-- 単一のDOSターミナル -->
                                </div>
                            }
                            else if (bottomPanelTab == BottomPanelTab.TaskRunner)
                            {
                                <div class="h-100 p-3 d-flex">
                                    <!-- npm scripts一覧 (30%) -->
                                    <div style="width: 30%; overflow-y: auto; padding-right: 1rem;">
                                        <h6 class="mb-3">NPM Scripts</h6>
                                        @if (npmScripts != null && npmScripts.Count > 0)
                                        {
                                            <div class="list-group">
                                                @foreach (var script in npmScripts)
                                                {
                                                    <div class="list-group-item" 
                                                         style="cursor: pointer; @(selectedScript == script.Key ? "background-color: #e7f1ff; border-color: #0d6efd; border-width: 2px;" : "")"
                                                         @onclick="() => SelectScript(script.Key)">
                                                        <div class="d-flex justify-content-between align-items-start mb-2">
                                                            <div class="d-flex align-items-start flex-grow-1">
                                                                @* チェックボックスを一時的に無効化
                                                                <input type="checkbox" 
                                                                       class="form-check-input me-2" 
                                                                       id="@($"script-check-{script.Key}")"
                                                                       checked="@checkedScripts.Contains(script.Key)"
                                                                       @onchange="() => ToggleScriptCheck(script.Key)"
                                                                       @onclick:stopPropagation="true" />
                                                                *@
                                                                <div class="flex-grow-1">
                                                                    <label for="@($"script-check-{script.Key}")" class="mb-0">
                                                                        <strong>@script.Key</strong>
                                                                    </label>
                                                                    <div class="small text-muted" style="white-space: pre-wrap;">@script.Value</div>
                                                                </div>
                                                            </div>
                                                            @if (runningScripts.Contains(script.Key))
                                                            {
                                                                <span class="spinner-border spinner-border-sm text-primary ms-2" role="status">
                                                                    <span class="visually-hidden">Loading...</span>
                                                                </span>
                                                            }
                                                        </div>
                                                        @if (selectedScript == script.Key)
                                                        {
                                                            <div class="d-flex gap-2">
                                                                @if (!runningScripts.Contains(script.Key))
                                                                {
                                                                    <button class="btn btn-primary btn-sm flex-fill" @onclick="RunSelectedScript" @onclick:stopPropagation="true">
                                                                        <i class="bi bi-play-fill"></i> 実行
                                                                    </button>
                                                                }
                                                                else
                                                                {
                                                                    <button class="btn btn-danger btn-sm flex-fill" @onclick="StopSelectedScript" @onclick:stopPropagation="true">
                                                                        <i class="bi bi-stop-fill"></i> 停止
                                                                    </button>
                                                                }
                                                            </div>
                                                        }
                                                    </div>
                                                }
                                            </div>
                                        }
                                        else
                                        {
                                            <div class="alert alert-info">
                                                <i class="bi bi-info-circle"></i> npm scriptsが見つかりません
                                            </div>
                                        }
                                    </div>
                                    
                                    <!-- タスク実行ターミナル (70%) -->
                                    <div style="width: 70%; padding-left: 1rem; border-left: 1px solid #dee2e6;">
                                        <div class="h-100" id="task-runner-terminal" style="background-color: #000; width: 100%; height: 100%;">
                                            <!-- タスクランナー用ターミナル -->
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="d-flex align-items-center justify-content-center h-100">
                    <div class="text-center text-muted">
                        <i class="bi bi-terminal" style="font-size: 4rem;"></i>
                        <p class="mt-3">左側からセッションを選択してください</p>
                    </div>
                </div>
            }
        </div>
    </div>
</div>


@code {
    private List<SessionInfo> sessions = new();
    private Guid? activeSessionId;
    private bool isAddingSession = false;
    private bool showCreateDialog = false;
    private IJSObjectReference? activeTerminal;
    private ConPtySession? activeSession;
    
    private DotNetObjectReference<Root>? dotNetRef;
    private Toast? toast;
    private string inputText = "";
    private BottomPanelTab bottomPanelTab = BottomPanelTab.TextInput; // デフォルトはテキスト入力タブ
    private IJSObjectReference? singleDosTerminal; // 単一のDOSターミナルXTermインスタンス
    private Guid? currentDosTerminalSessionId; // 現在DOSターミナルに接続しているセッションID
    private bool shouldPreventDefault = false;
    private Guid? editingMemoSessionId = null;
    private string tempMemoText = "";
    private bool showDevWindow = false;
    private bool showDevButton = false;
    private bool showSettingsDialog = false;
    private bool showSubSessionDialog = false;
    private string? subSessionParentSessionName = null;
    private Guid? subSessionParentSessionId = null;
    private string? subSessionParentSessionPath = null;
    private bool subSessionParentSessionIsGitRepository = true;
    private bool showSessionSettingsDialog = false;
    private Guid? settingsSessionId = null;
    
    // タスクランナー関連
    private bool hasPackageJson = false;
    private Dictionary<string, string>? npmScripts = null;
    private string? selectedScript = null;
    private HashSet<string> runningScripts = new HashSet<string>();
    private HashSet<string> checkedScripts = new HashSet<string>();
    private IJSObjectReference? taskRunnerTerminal;
    private ConPtySession? taskRunnerSession;
    private bool TaskRunnerInitialized = false;
    
    // スナップショット設定
    private int _defaultSnapshotLines = 50;
    private int _recreateSnapshotLines = 100;
    

    protected override Task OnInitializedAsync()
    {
        dotNetRef = DotNetObjectReference.Create(this);

        // 開発モード設定を読み込み
        showDevButton = Configuration.GetValue<bool>("DevelopmentMode:ShowDevButton", false);
        showDevWindow = Configuration.GetValue<bool>("DevelopmentMode:ShowDevWindowOnStartup", false);
        
        // スナップショット設定を読み込み
        _defaultSnapshotLines = Configuration.GetValue<int>("TerminalSettings:DefaultSnapshotLines", 50);
        _recreateSnapshotLines = Configuration.GetValue<int>("TerminalSettings:RecreateSnapshotLines", 100);
        
        // 通知権限をリクエスト（削除 - 設定モーダルに移動）
        // await NotificationService.RequestBrowserNotificationPermissionAsync();
        
        // OutputAnalyzerServiceのタイムアウトコールバックを設定
        OutputAnalyzerService.SetTimeoutCallback(sessionId => 
        {
            InvokeAsync(() => OnSessionTimeout(sessionId));
        });
        
        // JavaScript interopはOnAfterRenderAsyncで実行
        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // キーボードショートカットを登録
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setupKeyboardShortcuts", dotNetRef);
            // 通知用のDotNetRefを設定
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setDotNetRef", dotNetRef);
            
            // テキスト履歴を読み込み
            await InputHistoryService.LoadHistoryAsync();
            
            // ローカルストレージからセッション情報を復元
            var savedSessions = await LocalStorageService.LoadSessionsAsync();
            var savedActiveId = await LocalStorageService.LoadActiveSessionIdAsync();

            // 保存されたセッション情報をSessionManagerに復元
            var restoredSessionIds = new HashSet<Guid>();
            foreach (var sessionInfo in savedSessions)
            {
                // 重複チェック（ホットリロード対策）
                var existingSession = SessionManager.GetSessionInfo(sessionInfo.SessionId);
                if (existingSession != null)
                {
                    restoredSessionIds.Add(sessionInfo.SessionId);
                    continue;
                }

                // セッションを再作成（ターミナルプロセスの起動）- 元のSessionIDを使用
                try
                {
                    var newSession = await SessionManager.CreateSessionAsync(
                        sessionInfo.SessionId,
                        sessionInfo.FolderPath,
                        sessionInfo.DisplayName ?? "",
                        sessionInfo.TerminalType,
                        sessionInfo.Options);

                    // メモ情報と親子関係を復元
                    var createdSession = SessionManager.GetSessionInfo(newSession.SessionId);
                    if (createdSession != null)
                    {
                        if (!string.IsNullOrEmpty(sessionInfo.Memo))
                        {
                            createdSession.Memo = sessionInfo.Memo;
                        }
                        
                        // チェックされたスクリプトを復元
                        if (sessionInfo.CheckedScripts != null && sessionInfo.CheckedScripts.Count > 0)
                        {
                            createdSession.CheckedScripts = new HashSet<string>(sessionInfo.CheckedScripts);
                            Console.WriteLine($"[OnInitialized] Restored {sessionInfo.CheckedScripts.Count} checked scripts for session {sessionInfo.DisplayName}: {string.Join(", ", sessionInfo.CheckedScripts)}");
                        }
                        
                        // 親子関係を復元
                        if (sessionInfo.ParentSessionId.HasValue)
                        {
                            createdSession.ParentSessionId = sessionInfo.ParentSessionId;
                        }
                        
                        await SessionManager.SaveSessionInfoAsync(createdSession);
                    }

                    restoredSessionIds.Add(newSession.SessionId);
                }
                catch (Exception)
                {
                    // Failed to restore session
                }
            }

            sessions = SessionManager.GetAllSessions().ToList();
            
            // 保存された展開状態を読み込んで適用
            var expandedStates = await LocalStorageService.LoadSessionExpandedStatesAsync();
            foreach (var session in sessions)
            {
                if (!session.ParentSessionId.HasValue && expandedStates.ContainsKey(session.SessionId))
                {
                    session.IsExpanded = expandedStates[session.SessionId];
                }
            }
            
            // すべてのセッションにイベントハンドラーを設定
            foreach (var session in sessions)
            {
                SetupSessionEventHandlers(session);
            }

            // 保存されたアクティブセッションがあれば選択
            if (savedActiveId != null && sessions.Any(s => s.SessionId == savedActiveId))
            {
                await SelectSession(savedActiveId.Value);
            }
            
            // UIを更新
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task OnNotificationClick(string sessionId)
    {
        if (Guid.TryParse(sessionId, out var guid))
        {
            await SelectSession(guid);
        }
    }

    private async Task AddSession()
    {
        showCreateDialog = true;
        await Task.CompletedTask; // 必要に応じて非同期処理を追加
    }
    
    private void ShowSettings()
    {
        showSettingsDialog = true;
    }
    
    private async Task SwitchBottomPanelTab(BottomPanelTab tab)
    {
        Console.WriteLine($"[SwitchBottomPanelTab] タブ切り替え: {bottomPanelTab} -> {tab}, activeSessionId={activeSessionId}");
        bottomPanelTab = tab;
        StateHasChanged();
        
        if (tab == BottomPanelTab.DosTerminal && activeSessionId != null)
        {
            // DOSターミナルタブに切り替え - 常に新しいXTermを作成
            Console.WriteLine("[SwitchBottomPanelTab] DOSターミナルタブに切り替え");
            await CleanupSingleDosTerminal();
            // タスクランナーターミナルはクリーンアップしない（保持）
            await InitializeSingleDosTerminal();
        }
        else if (tab == BottomPanelTab.TaskRunner && activeSessionId != null)
        {
            // タスクランナータブに切り替え
            Console.WriteLine($"[SwitchBottomPanelTab] タスクランナータブに切り替え - TaskRunnerInitialized: {TaskRunnerInitialized}");
            await CleanupSingleDosTerminal();
            
            // 現在のセッションのpackage.jsonを確認
            var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
            if (currentSession != null)
            {
                hasPackageJson = await PackageJsonService.HasPackageJsonAsync(currentSession.FolderPath);
                Console.WriteLine($"[SwitchBottomPanelTab] TaskRunner - Session: {currentSession.DisplayName}, hasPackageJson: {hasPackageJson}");
                // package.jsonの有無に関わらずタスクランナーを表示
                await LoadNpmScripts();
                
                // 既に初期化済みの場合は再初期化しない
                if (!TaskRunnerInitialized)
                {
                    Console.WriteLine("[SwitchBottomPanelTab] タスクランナーターミナルを初期化");
                    await InitializeTaskRunnerTerminal();
                }
                else
                {
                    Console.WriteLine("[SwitchBottomPanelTab] タスクランナーターミナルは既に初期化済み - 表示のみ");
                    // 既存のターミナルを表示
                    if (taskRunnerTerminal != null)
                    {
                        await JSRuntime.InvokeVoidAsync("terminalFunctions.showTerminal", "task-runner-terminal");
                    }
                }
            }
        }
        else if (tab == BottomPanelTab.TextInput)
        {
            // テキスト入力タブに切り替え - DOSターミナルのみクリーンアップ
            // タスクランナーターミナルは保持（タスク実行ボタンから使う可能性があるため）
            Console.WriteLine("[SwitchBottomPanelTab] テキスト入力に切り替え - DOSターミナルのみクリーンアップ");
            await CleanupSingleDosTerminal();
        }
    }
    
    private async Task InitializeSingleDosTerminal()
    {
        try
        {
            if (activeSessionId == null) return;
            
            var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
            if (currentSession == null) return;
            
            
            // ConPTYセッションがなければ作成
            if (currentSession.DosTerminalConPtySession == null)
            {
                var conPtyService = new ConPtyService(LoggerFactory.Create(builder => builder.AddConsole()).CreateLogger<ConPtyService>());
                var conPtySession = await conPtyService.CreateSessionAsync("cmd.exe", "", currentSession.FolderPath, 120, 30);
                
                currentSession.DosTerminalConPtySession = conPtySession;
                conPtySession.Start();
                conPtySession.DataReceived += (sender, args) => OnDosTerminalDataReceived(currentSession.SessionId, args.Data);
                conPtySession.ProcessExited += (sender, args) => OnDosTerminalExited(currentSession.SessionId);
                
                // ConPTYの初期化が完了するまで少し待つ
                await Task.Delay(100);
            }
            
            // DOM要素の存在を確認
            var elementExists = await JSRuntime.InvokeAsync<bool>("eval", @"
                !!document.getElementById('dos-terminal-container')
            ");
            
            if (!elementExists)
            {
                StateHasChanged();
                await Task.Delay(200); // DOM更新を待つ
            }
            
            // 新しいXTermを作成
            singleDosTerminal = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "terminalFunctions.createMultiSessionTerminal",
                "dos-terminal-container",
                $"dos-terminal-{activeSessionId}",
                dotNetRef
            );
            
            currentDosTerminalSessionId = activeSessionId;
            
            // リサイズは再接続時に自動的に送られるため、ここでは明示的に送らない
            
            // フォーカスとリサイズ
            await JSRuntime.InvokeVoidAsync("eval", $@"
                (function() {{
                    const termObj = window.multiSessionTerminals && window.multiSessionTerminals['dos-terminal-{activeSessionId}'];
                    if (termObj && termObj.terminal) {{
                        termObj.terminal.focus();
                        if (termObj.fitAddon) {{
                            termObj.fitAddon.fit();
                        }}
                    }}
                }})()
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[InitializeSingleDosTerminal] エラー: {ex.Message}");
            toast?.ShowError($"DOSターミナルの初期化エラー: {ex.Message}");
        }
    }
    
    private async Task CleanupSingleDosTerminal()
    {
        try
        {
            if (singleDosTerminal != null)
            {
                
                // JavaScriptで破棄
                await JSRuntime.InvokeVoidAsync("eval", $@"
                    (function() {{
                        const terminalId = 'dos-terminal-{currentDosTerminalSessionId}';
                        const termObj = window.multiSessionTerminals && window.multiSessionTerminals[terminalId];
                        if (termObj) {{
                            termObj.terminal.dispose();
                            delete window.multiSessionTerminals[terminalId];
                        }}
                    }})()
                ");
                
                await singleDosTerminal.DisposeAsync();
                singleDosTerminal = null;
                currentDosTerminalSessionId = null;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[CleanupSingleDosTerminal] エラー: {ex.Message}");
        }
    }
    
    private async void OnDosTerminalDataReceived(Guid sessionId, string data)
    {
        // アクティブなセッションのDOSターミナルデータのみ表示
        if (singleDosTerminal != null && sessionId == currentDosTerminalSessionId)
        {
            await InvokeAsync(async () =>
            {
                await singleDosTerminal.InvokeVoidAsync("write", data);
            });
        }
    }
    
    private void OnDosTerminalExited(Guid sessionId)
    {
        InvokeAsync(async () =>
        {
            var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
            if (session != null)
            {
                // 現在表示中のDOSターミナルの場合はクリーンアップ
                if (currentDosTerminalSessionId == sessionId)
                {
                    await CleanupSingleDosTerminal();
                }
                
                session.DosTerminalConPtySession?.Dispose();
                session.DosTerminalConPtySession = null;
                
                // 再起動できるように通知
                StateHasChanged();
            }
        });
    }

    private async Task OnSessionCreate(SessionCreateDialog.SessionCreateResult result)
    {
        showCreateDialog = false;
        isAddingSession = true;

        try
        {
            var sessionInfo = await SessionManager.CreateSessionAsync(
                result.FolderPath, 
                "", // セッション名は空（フォルダ名を使用）
                result.TerminalType, 
                result.Options);

            sessions = SessionManager.GetAllSessions().ToList();

            // ローカルストレージに保存
            await LocalStorageService.SaveSessionsAsync(sessions);
            
            // 新しいセッションのConPtySessionにイベントハンドラーを設定
            SetupSessionEventHandlers(sessionInfo);

            StateHasChanged();

            await Task.Delay(TerminalConstants.DomUpdateDelay);
            await SelectSession(sessionInfo.SessionId);
        }
        catch (Exception ex)
        {
            toast?.ShowError($"セッション作成エラー: {ex.Message}");
        }
        finally
        {
            isAddingSession = false;
        }
    }

    private void OnDialogCancel()
    {
        showCreateDialog = false;
    }


    private async Task SelectSession(Guid sessionId)
    {
        Console.WriteLine($"[SelectSession] 開始: sessionId={sessionId}");
        
        if (activeSessionId == sessionId)
        {
            Console.WriteLine($"[SelectSession] 既にアクティブなセッション: {sessionId}");
            return;
        }

        // 前のセッションの処理は継続させるため、キャンセルしない

        // 既存のアクティブターミナルを破棄
        if (activeTerminal != null)
        {
            Console.WriteLine($"[SelectSession] 既存のアクティブターミナルを破棄");
            try
            {
                await activeTerminal.DisposeAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SelectSession] ターミナル破棄エラー: {ex.Message}");
            }
            activeTerminal = null;
        }

        // すべてのターミナルを非表示にする（JavaScriptで直接制御）
        Console.WriteLine($"[SelectSession] すべてのターミナルを非表示に");
        await TerminalService.HideAllTerminalsAsync();

        // セッションをアクティブに
        Console.WriteLine($"[SelectSession] SessionManagerでアクティブに設定");
        await SessionManager.SetActiveSessionAsync(sessionId);
        activeSessionId = sessionId;
        
        // セッション情報を取得して、初期化中の場合はUIを更新
        var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionInfo != null && sessionInfo.ConPtySession == null)
        {
            Console.WriteLine($"[SelectSession] ConPtyがまだ初期化されていない - スピナー表示");
            // ConPtyがまだ初期化されていない場合
            sessionInfo.IsInitializing = true;
            StateHasChanged(); // スピナーを表示するためにUIを更新
        }
        
        // 再起動後の新しいセッションを確実に取得
        Console.WriteLine($"[SelectSession] SessionManager.GetSessionAsync呼び出し");
        activeSession = await SessionManager.GetSessionAsync(sessionId);
        Console.WriteLine($"[SelectSession] SessionManager.GetSession結果: {(activeSession != null ? "成功" : "失敗")}");
        
        // セッションが存在しない場合はエラー
        if (activeSession == null)
        {
            // セッションが見つからない
            activeSessionId = null;
            return;
        }
        
        // ConPty接続は完了したが、まだXTermの初期表示待ち
        // IsInitializingフラグは維持（最初のデータ受信時にリセット）
        
        // 通知フラグをクリア
        var selectedSession = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (selectedSession != null && selectedSession.HasNotificationPending)
        {
            selectedSession.HasNotificationPending = false;
            //Console.WriteLine($"[Notification Debug] セッション {sessionId} の通知フラグをクリア");
        }

        // アクティブセッション変更を即座にUIに反映
        StateHasChanged();

        // アクティブセッションIDをローカルストレージに保存
        await LocalStorageService.SaveActiveSessionIdAsync(sessionId);

        // ターミナルdivが存在するか確認し、表示する
        Console.WriteLine($"[SelectSession] ターミナルdivの存在確認");
        var divExists = await TerminalService.CheckElementExistsAsync($"terminal-{sessionId}");
        Console.WriteLine($"[SelectSession] ターミナルdiv存在: {divExists}");
        if (divExists)
        {
            // 新しいターミナルを表示
            Console.WriteLine($"[SelectSession] ターミナルを表示");
            await TerminalService.ShowTerminalAsync(sessionId);
        }

        // ターミナルを初期化
        Console.WriteLine($"[SelectSession] InitializeTerminal呼び出し");
        await InitializeTerminal(sessionId);

        // ターミナルのリサイズを強制的に実行
        if (activeTerminal != null)
        {
            await TerminalService.ResizeTerminalAsync(activeTerminal);
        }

        // ConPtyBufferのリサイズトリックは不要になったため削除


        // ConPtySessionのイベントハンドラーを設定
        if (selectedSession?.ConPtySession != null)
        {
            // ConPtySessionイベントハンドラーを設定
            // ※ ConPtySessionにはClearEventHandlersメソッドは必要ない
            

                        // イベントハンドラーを設定
            SetupSessionEventHandlers(selectedSession);
            
            // 切断時にタイマーをクリーンアップ
        }
        else
        {
            // ConPtySessionが利用不可
        }

        // ターミナルを最下段にスクロール
   //     await TerminalService.ScrollToBottomAsync(sessionId);
        
        // package.jsonの存在をチェック
        if (selectedSession != null)
        {
            hasPackageJson = await PackageJsonService.HasPackageJsonAsync(selectedSession.FolderPath);
            Console.WriteLine($"[SelectSession] Session: {selectedSession.DisplayName}, Path: {selectedSession.FolderPath}, hasPackageJson: {hasPackageJson}");
            
            // チェックされたスクリプトを復元
            checkedScripts = new HashSet<string>(selectedSession.CheckedScripts);
            Console.WriteLine($"[SelectSession] Restored {checkedScripts.Count} checked scripts: {string.Join(", ", checkedScripts)}");
            
            StateHasChanged(); // UIを更新
        }

        // テキストエリアにフォーカス
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.focusTextArea");
        }
        catch (Exception)
        {
            // エラーは無視
        }
        
        // 現在のタブに応じてターミナルを再作成
        if (bottomPanelTab == BottomPanelTab.DosTerminal && selectedSession != null)
        {
            Console.WriteLine($"[SelectSession] DOSターミナルタブが選択されているのでXTermを再作成");
            
            // 既存のDOSターミナルをクリーンアップして新しく作成
            await CleanupSingleDosTerminal();
            await InitializeSingleDosTerminal();
        }
        else if (bottomPanelTab == BottomPanelTab.TaskRunner && selectedSession != null)
        {
            Console.WriteLine($"[SelectSession] タスクランナータブが選択されているのでnpm scriptsを読み込み");
            
            // npm scriptsを読み込み
            await LoadNpmScripts();
            await InitializeTaskRunnerTerminal();
        }
    }

    private async Task InitializeTerminal(Guid sessionId)
    {
        activeTerminal = await TerminalService.InitializeTerminalAsync(sessionId, DotNetObjectReference.Create<object>(this));
    }

    private async Task ProcessReceivedData(Guid sessionId, string data)
    {
        try
        {
            var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
            if (sessionInfo != null)
            {
                // 最初のデータ受信を検出
                if (!sessionInfo.HasReceivedFirstData && !string.IsNullOrEmpty(data))
                {
                    Console.WriteLine($"[ProcessReceivedData] セッション {sessionId} の最初のデータ受信 (長さ: {data.Length})");
                    sessionInfo.HasReceivedFirstData = true;
                    
                    // 初期化完了としてフラグをリセット
                    if (sessionInfo.IsInitializing)
                    {
                        Console.WriteLine($"[ProcessReceivedData] 初期化完了 - スピナー非表示 {DateTime.Now}");
                        sessionInfo.IsInitializing = false;
                        // UIを更新してスピナーを非表示にする
                        _ = InvokeAsync(StateHasChanged);
                    }
                }
                // Claude Codeの場合、"No conversation found to continue"エラーをチェック
                if (sessionInfo.TerminalType == TerminalType.ClaudeCode && 
                    data.StartsWith("No conversation found to continue") &&
                    sessionInfo.Options.ContainsKey("continue") &&
                    !sessionInfo.HasContinueErrorOccurred)
                {
                    // Claude Continue Error detected
                    
                    // フラグを設定して重複送信を防ぐ
                    sessionInfo.HasContinueErrorOccurred = true;
                    
                    // セッション再起動のコマンドを送信
                    _ = InvokeAsync(async () =>
                    {
                        await RestartSessionWithoutContinue(sessionId);
                    });
                    return;
                }

                // アクティブセッションの場合は直接ターミナルに出力
                if (activeSessionId == sessionId && activeTerminal != null)
                {
                    //Console.WriteLine($"[ProcessReceivedData] アクティブセッション - XTermにデータ送信 (長さ: {data.Length}) {DateTime.Now }");
                    await TerminalService.WriteToTerminalAsync(activeTerminal, data);
                    
                    // 出力解析の実行
                    _ = InvokeAsync(() => 
                    {
                        OutputAnalyzerService.AnalyzeOutput(data, sessionInfo, activeSessionId ?? Guid.Empty,
                            (id, status) => InvokeAsync(() => 
                            {
                                StateHasChanged();
                            }));
                    });
                }
                else
                {
                    //Console.WriteLine($"[ProcessReceivedData] 非アクティブセッション {sessionId} - バッファのみ更新 {DateTime.Now}");
                    // 非アクティブセッションの場合もデータを処理
                    // ただし、出力解析は実行してステータスを更新
                    _ = InvokeAsync(() => 
                    {
                        OutputAnalyzerService.AnalyzeOutput(data, sessionInfo, activeSessionId ?? Guid.Empty,
                            (id, status) => InvokeAsync(() => 
                            {
                                StateHasChanged();
                            }));
                    });
                }
            }
        }
        catch (Exception)
        {
            // ProcessReceivedData error
        }
    }


    private void StartEditingMemo(Guid sessionId, string currentMemo)
    {
        editingMemoSessionId = sessionId;
        tempMemoText = currentMemo ?? "";
        StateHasChanged();
    }
    
    private async Task HandleSessionExpandedChanged((Guid sessionId, bool isExpanded) args)
    {
        // 展開状態をLocalStorageに保存
        await SaveExpandedStatesToLocalStorage();
    }
    
    private async Task SaveExpandedStatesToLocalStorage()
    {
        var expandedStates = sessions
            .Where(s => !s.ParentSessionId.HasValue) // 親セッションのみ
            .ToDictionary(s => s.SessionId, s => s.IsExpanded);
            
        await LocalStorageService.SaveSessionExpandedStatesAsync(expandedStates);
    }

    private async Task SaveMemo(Guid sessionId)
    {
        if (editingMemoSessionId == sessionId)
        {
            await UpdateSessionMemo(sessionId, tempMemoText);
            editingMemoSessionId = null;
            tempMemoText = "";
            StateHasChanged();
        }
    }

    private async Task HandleMemoKeyDown(KeyboardEventArgs e, Guid sessionId)
    {
        if (e.Key == "Enter")
        {
            await SaveMemo(sessionId);
        }
        else if (e.Key == "Escape")
        {
            editingMemoSessionId = null;
            tempMemoText = "";
            StateHasChanged();
        }
    }

    private async Task UpdateSessionMemo(Guid sessionId, string memo)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            session.Memo = memo;
            // ローカルストレージを更新
            await LocalStorageService.SaveSessionsAsync(sessions);
        }
    }

    private async Task RemoveSession(Guid sessionId)
    {
        // ConPtySessionのクリーンアップ
        var sessionToRemove = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionToRemove != null)
        {
            // 現在表示中のDOSターミナルを使用している場合はクリーンアップ
            if (currentDosTerminalSessionId == sessionId)
            {
                await CleanupSingleDosTerminal();
            }
            
            // DOS ConPTYセッションのクリーンアップ
            sessionToRemove.DosTerminalConPtySession?.Dispose();
            sessionToRemove.DosTerminalConPtySession = null;
            
            // ConPtySessionのクリーンアップ
            if (sessionToRemove.ConPtySession != null)
            {
                sessionToRemove.ConPtySession.Dispose();
            }
        }
        
        // セッションのタイマーを停止
        OutputAnalyzerService.StopSessionTimer(sessionId);


        // アクティブセッションの場合の追加処理
        if (sessionId == activeSessionId)
        {

            if (activeTerminal != null)
            {
                await activeTerminal.DisposeAsync();
                activeTerminal = null;
            }
        }

        // ターミナルのクリーンアップはdestroyTerminalで処理される

        await SessionManager.RemoveSessionAsync(sessionId);
        sessions = SessionManager.GetAllSessions().ToList();

        // ローカルストレージを更新
        await LocalStorageService.SaveSessionsAsync(sessions);

        if (activeSessionId == sessionId)
        {
            activeSessionId = null;
            activeSession = null;

            // セッション削除を即座にUIに反映
            StateHasChanged();

            await LocalStorageService.SaveActiveSessionIdAsync(null);

            // 他のセッションがあれば最初のものを選択
            if (sessions.Any())
            {
                await SelectSession(sessions.First().SessionId);
            }
        }
        else
        {
            // 削除されたセッションがアクティブでない場合もUIを更新
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task SendInput(string sessionId, string data)
    {
        Console.WriteLine($"[SendInput JSInvokable] 呼び出し - sessionId: {sessionId}, data長: {data?.Length ?? 0}");
        
        try
        {
            // タスクランナーターミナルからの入力を処理
            if (sessionId == "task-runner-terminal")
            {
                Console.WriteLine($"[SendInput JSInvokable] タスクランナーターミナルからの入力: {data}");
                if (taskRunnerSession != null)
                {
                    await taskRunnerSession.WriteAsync(data);
                    Console.WriteLine("[SendInput JSInvokable] タスクランナーへの送信完了");
                }
                else
                {
                    Console.WriteLine("[SendInput JSInvokable] エラー: taskRunnerSessionがnull");
                }
            }
            // DOSターミナルからの入力を処理
            else if (sessionId.StartsWith("dos-terminal-"))
            {
                var guidStr = sessionId.Replace("dos-terminal-", "");
                if (Guid.TryParse(guidStr, out var guid))
                {
                    var session = sessions.FirstOrDefault(s => s.SessionId == guid);
                    if (session?.DosTerminalConPtySession != null)
                    {
                        await session.DosTerminalConPtySession.WriteAsync(data);
                    }
                }
            }
            else
            {
                // 通常のセッションからの入力を処理
                var guid = Guid.Parse(sessionId);
                if (activeSession != null && guid == activeSessionId)
                {
                    await activeSession.WriteAsync(data);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SendInput JSInvokable] エラー: {ex.GetType().Name} - {ex.Message}");
            throw;
        }
    }

    [JSInvokable]
    public void OnTerminalSizeChanged(string sessionId, int cols, int rows)
    {
        // DOSターミナルのサイズ変更を処理
        if (sessionId.StartsWith("dos-terminal-"))
        {
            var guidStr = sessionId.Replace("dos-terminal-", "");
            if (Guid.TryParse(guidStr, out var guid))
            {
                var session = sessions.FirstOrDefault(s => s.SessionId == guid);
                if (session?.DosTerminalConPtySession != null)
                {
                    session.DosTerminalConPtySession.Resize(cols, rows);
                }
            }
        }
        else
        {
            // 通常のセッションのサイズ変更を処理
            if (!Guid.TryParse(sessionId, out var guid))
            {
                // GUIDではない値（タスクランナーなど）は無視
                return;
            }
            if (guid == activeSessionId && activeSession != null)
            {
                // ConPtyにリサイズを通知
                activeSession.Resize(cols, rows);
                
                // ConPtySessionもリサイズを通知
                var selectedSession = sessions.FirstOrDefault(s => s.SessionId == guid);
                if (selectedSession?.ConPtySession != null)
                {
                    selectedSession.ConPtySession.Resize(cols, rows);
                }
                
                // リサイズ時のスナップショット再表示は削除
                // ConPTYは自身でリフロー処理を行い、アプリケーションが再描画する
                // 手動でクリア＆再描画すると、ConPTYの再描画と競合する可能性がある
            }
        }
    }

    private async Task DestroyTerminal(Guid sessionId, bool showAlert = true)
    {
        try
        {
            // JavaScript側のターミナルを破棄
            await TerminalService.DestroyTerminalAsync(sessionId, showAlert);

            // C#側のターミナル参照を削除（アクティブセッションの場合のみ）
            if (activeSessionId == sessionId && activeTerminal != null)
            {
                await activeTerminal.DisposeAsync();
                activeTerminal = null;
            }

            if (showAlert)
            {
                toast?.ShowSuccess("ターミナルを破棄しました");
            }
        }
        catch (Exception ex)
        {
            if (showAlert)
            {
                toast?.ShowError($"ターミナル破棄エラー: {ex.Message}");
            }
        }
    }

    private async Task RecreateTerminal(Guid sessionId)
    {
        try
        {
            // セッションがアクティブな場合のみ再作成
            if (activeSessionId == sessionId)
            {
                // 既存のターミナルを破棄（アラートなし）
                await DestroyTerminal(sessionId, false);

                // 新しいターミナルを初期化
                await InitializeTerminal(sessionId);

                // ターミナル再作成処理
                var selectedSessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
                await TerminalService.RecreateTerminalAsync(sessionId, selectedSessionInfo!, activeSession);

                // イベントハンドラーを設定
                if (selectedSessionInfo != null)
                {
                    SetupSessionEventHandlers(selectedSessionInfo);
                }

                toast?.ShowSuccess("ターミナルを再作成しました");
            }
            else
            {
                toast?.ShowWarning("このセッションを選択してからターミナルを再作成してください");
            }
        }
        catch (Exception ex)
        {
            toast?.ShowError($"ターミナル再作成エラー: {ex.Message}");
        }
    }




    
    

    
    

    private async Task SendInput()
    {
        Console.WriteLine($"[SendInputボタン] 呼び出し - activeSessionId: {activeSessionId}, activeSession: {(activeSession != null ? "存在" : "null")}");
        
        if (activeSession == null)
        {
            Console.WriteLine("[SendInputボタン] activeSessionがnullのため中断");
            return;
        }

        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null)
        {
            Console.WriteLine("[SendInputボタン] currentSessionが見つからないため中断");
            return;
        }

        // テキストがある場合は送信
        if (!string.IsNullOrWhiteSpace(inputText))
        {
            Console.WriteLine($"[SendInputボタン] テキスト送信: {inputText}");
            
            // テキスト履歴に追加
            InputHistoryService.AddToHistory(inputText);
            
            try
            {
                Console.WriteLine("[SendInputボタン] activeSession.WriteAsync呼び出し");
                await activeSession.WriteAsync(inputText);
                Console.WriteLine("[SendInputボタン] WriteAsync完了");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SendInputボタン] WriteAsyncエラー: {ex.GetType().Name} - {ex.Message}");
                throw;
            }
            
            // テキスト送信後、Enter送信前に0.2秒待機
            await Task.Delay(200);
        }
        
        // Enterキーを送信（空の場合でも送信）
        Console.WriteLine("[SendInputボタン] Enterキー送信");
        await SendEnterKeyDirect();
        
        // 入力フィールドをクリア
        inputText = "";
        Console.WriteLine("[SendInputボタン] 完了");
    }

    private async Task OnTextAreaKeyDown(KeyboardEventArgs e)
    {
        // Enter で送信（Shiftキーが押されていない場合）
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            shouldPreventDefault = true;
            await SendInput();
            shouldPreventDefault = false;
        }
        // 履歴機能: 上矢印で前の履歴、下矢印で次の履歴
        else if (e.Key == "ArrowUp" && e.CtrlKey)
        {
            shouldPreventDefault = true;
            var historyText = InputHistoryService.NavigateHistory(-1);
            if (historyText != null)
                inputText = historyText;
        }
        else if (e.Key == "ArrowDown" && e.CtrlKey)
        {
            shouldPreventDefault = true;
            var historyText = InputHistoryService.NavigateHistory(1);
            if (historyText != null)
                inputText = historyText;
        }
        else
        {
            shouldPreventDefault = false;
        }
        // Shift+Enter は通常の改行動作（何もしない）
    }

    private string GetPlaceholderText(TerminalType terminalType)
    {
        return terminalType switch
        {
            TerminalType.ClaudeCode => "Claude Codeへのメッセージを入力...",
            TerminalType.GeminiCLI => "Gemini CLIへのメッセージを入力...",
            _ => "コマンドを入力..."
        };
    }

    private bool isEscapePressed = false;
    private bool isModeSwitchPressed = false;
    private bool isCtrlCPressed = false;

    private async Task SendCtrlC()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isCtrlCPressed = true;

        // Ctrl+Cを送信（\x03 はCtrl+Cの制御文字）
        await activeSession.WriteAsync("\x03");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isCtrlCPressed = false;
    }

    private async Task SendEscape()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isEscapePressed = true;

        // Escキーを送信（\x1B はESCのエスケープシーケンス）
        await activeSession.WriteAsync("\x1B");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isEscapePressed = false;
    }

    private async Task SendModeSwitch()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isModeSwitchPressed = true;

        // Alt+M を送信（\x1B はESC、m はM）
        await activeSession.WriteAsync("\x1Bm");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isModeSwitchPressed = false;
    }


    private void ShowWorktreeDialog(Guid sessionId)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            // Git管理されていない場合でも、サブセッションダイアログは表示する
            // （同じフォルダで開くオプションは利用可能）
            subSessionParentSessionId = sessionId;
            subSessionParentSessionName = session.GetDisplayName();
            subSessionParentSessionPath = session.FolderPath;
            subSessionParentSessionIsGitRepository = session.IsGitRepository;
            showSubSessionDialog = true;
        }
    }

    private async Task OnSubSessionOperation(SubSessionDialog.SubSessionResult result)
    {
        if (!subSessionParentSessionId.HasValue)
        {
            showSubSessionDialog = false;
            return;
        }

        try
        {
            SessionInfo? newSession = null;
            
            switch (result.OperationType)
            {
                case SubSessionDialog.SubSessionType.CreateNew:
                    // 新規Worktree作成
                    if (result.UseExistingBranch)
                    {
                        // 既存ブランチでWorktree作成
                        newSession = await SessionManager.CreateWorktreeSessionWithExistingBranchAsync(
                            subSessionParentSessionId.Value, result.BranchName, result.TerminalType, result.Options);
                    }
                    else
                    {
                        // 新規ブランチでWorktree作成
                        newSession = await SessionManager.CreateWorktreeSessionAsync(
                            subSessionParentSessionId.Value, result.BranchName, result.TerminalType, result.Options);
                    }
                    break;
                    
                case SubSessionDialog.SubSessionType.AddExisting:
                    // 既存Worktree追加
                    if (!string.IsNullOrEmpty(result.WorktreePath))
                    {
                        newSession = await AddExistingWorktreeSession(subSessionParentSessionId.Value, result.WorktreePath, result.BranchName, result.TerminalType, result.Options);
                    }
                    break;
                    
                case SubSessionDialog.SubSessionType.SamePath:
                    // 同じフォルダでセッション作成
                    if (!string.IsNullOrEmpty(subSessionParentSessionPath))
                    {
                        newSession = await SessionManager.CreateSamePathSessionAsync(
                            subSessionParentSessionId.Value, subSessionParentSessionPath, result.TerminalType, result.Options);
                    }
                    break;
                    
                case SubSessionDialog.SubSessionType.NewFolder:
                    // 新しいフォルダでセッション作成
                    if (!string.IsNullOrEmpty(result.WorktreePath))
                    {
                        newSession = await CreateNewFolderSession(
                            subSessionParentSessionId.Value, result.WorktreePath, result.TerminalType, result.Options);
                    }
                    break;
            }
            
            if (newSession != null)
            {
                // セッション一覧を更新
                sessions = SessionManager.GetAllSessions().ToList();
                
                // ローカルストレージに保存
                await LocalStorageService.SaveSessionsAsync(sessions);
                
                // 新しいセッションを選択
                await SelectSession(newSession.SessionId);
                
                string successMessage = result.OperationType switch
                {
                    SubSessionDialog.SubSessionType.CreateNew => 
                        $"Worktree '{result.BranchName}' を作成しました",
                    SubSessionDialog.SubSessionType.AddExisting => 
                        $"既存のWorktree '{result.BranchName}' を追加しました",
                    SubSessionDialog.SubSessionType.SamePath => 
                        $"新しい{GetSessionTypeName(result.TerminalType)}セッションを作成しました",
                    SubSessionDialog.SubSessionType.NewFolder => 
                        $"新しいフォルダ '{result.WorktreePath}' でセッションを作成しました",
                    _ => "セッションを作成しました"
                };
                
                toast?.ShowSuccess(successMessage);
            }
            else
            {
                toast?.ShowError("セッション作成に失敗しました");
            }
        }
        catch (Exception ex)
        {
            toast?.ShowError($"セッション作成エラー: {ex.Message}");
        }
        finally
        {
            showSubSessionDialog = false;
            subSessionParentSessionId = null;
            subSessionParentSessionName = null;
            subSessionParentSessionPath = null;
            subSessionParentSessionIsGitRepository = true;
        }
    }
    
    private string GetSessionTypeName(TerminalType terminalType)
    {
        return terminalType switch
        {
            TerminalType.Terminal => "ターミナル",
            TerminalType.ClaudeCode => "Claude Code",
            TerminalType.GeminiCLI => "Gemini CLI",
            _ => "セッション"
        };
    }
    
    private async Task<SessionInfo?> AddExistingWorktreeSession(Guid parentSessionId, string worktreePath, string branchName, TerminalType terminalType, Dictionary<string, string> options)
    {
        // 親セッション情報を取得
        var parentSession = SessionManager.GetSessionInfo(parentSessionId);
        if (parentSession == null)
        {
            // Parent session not found
            return null;
        }
            
        // 既存のWorktreeをセッションとして追加（統一された表示名を使用）
        var sessionInfo = await SessionManager.CreateSessionAsync(
            worktreePath,
            $"{parentSession.DisplayName} ({branchName})",
            terminalType,
            options
        );
        
        // 親子関係を設定
        if (sessionInfo != null)
        {
            sessionInfo.ParentSessionId = parentSessionId;
            await SessionManager.SaveSessionInfoAsync(sessionInfo);
        }
        
        return sessionInfo;
    }
    
    private async Task<SessionInfo?> CreateNewFolderSession(Guid parentSessionId, string folderPath, TerminalType terminalType, Dictionary<string, string> options)
    {
        try
        {
            // 親セッション情報を取得
            var parentSession = SessionManager.GetSessionInfo(parentSessionId);
            if (parentSession == null)
            {
                // Parent session not found
                return null;
            }
                
            // フォルダが存在しない場合は作成
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
            }
            
            // 新しいフォルダでセッション作成（統一された表示名を使用）
            var sessionInfo = await SessionManager.CreateSessionAsync(
                folderPath,
                $"{parentSession.DisplayName} ({Path.GetFileName(folderPath)})",
                terminalType,
                options
            );
            
            // 親子関係を設定
            if (sessionInfo != null)
            {
                sessionInfo.ParentSessionId = parentSessionId;
                await SessionManager.SaveSessionInfoAsync(sessionInfo);
            }
            
            return sessionInfo;
        }
        catch (Exception)
        {
            // CreateNewFolderSession error
            return null;
        }
    }


    private async Task SendEnterKeyDirect()
    {
        Console.WriteLine($"[SendEnterKeyDirect] 呼び出し - activeSession: {(activeSession != null ? "存在" : "null")}");
        
        if (activeSession == null)
        {
            Console.WriteLine("[SendEnterKeyDirect] activeSessionがnullのため中断");
            return;
        }

        try
        {
            // 様々なEnterキーのパターンを試す
            // Windows環境では通常 \r\n だが、ターミナルによって異なる場合がある
            Console.WriteLine("[SendEnterKeyDirect] Enterキー(\\r)送信");
            await activeSession.WriteAsync("\r");
            Console.WriteLine("[SendEnterKeyDirect] 送信完了");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SendEnterKeyDirect] エラー: {ex.GetType().Name} - {ex.Message}");
            throw;
        }
    }

    
    // テキスト履歴関連メソッド
    
    private async Task OnSessionTimeout(Guid sessionId)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            var lastUpdateTime = session.LastProcessingUpdateTime;
            if (!lastUpdateTime.HasValue)
            {
                return;
            }

            // ユーザー入力待ち状態の場合はタイムアウトしない
            if (session.IsWaitingForUserInput)
            {
                // タイマーを再設定
                OutputAnalyzerService.ResetSessionTimer(sessionId);
                return;
            }

            var elapsedTime = (DateTime.Now - lastUpdateTime.Value).TotalSeconds;

            if (elapsedTime >= 5)
            {
                // 5秒間更新がないため処理終了と判定
                Console.WriteLine($"[Session Timeout] セッション {sessionId} で5秒間更新がないため処理終了と判定");

                // ステータスを直接クリア（UpdateSessionProcessingStatusの処理完了ロジックを実行）
                session.ProcessingStatus = null;
                session.ProcessingStartTime = null;
                session.ProcessingElapsedSeconds = null;
                session.ProcessingTokens = null;
                session.ProcessingDirection = null;
                session.LastProcessingUpdateTime = null;
                session.LastProcessingSeconds = null;
                session.LastProcessingTokens = null;
                session.IsWaitingForUserInput = false;

                if(activeSessionId != sessionId)
                {
                    session.HasNotificationPending = true;
                }

                // 処理完了の通知
                if (!session.IsActive)
                {
                    await NotificationService.NotifyProcessingCompleteAsync(session, (int)elapsedTime)　;
                }

                // タイマーを停止
                OutputAnalyzerService.StopSessionTimer(sessionId);
                
                // UIを更新
                StateHasChanged();
            }
            else
            {
                // まだタイムアウトしていないので、タイマーを再設定
                OutputAnalyzerService.ResetSessionTimer(sessionId);
            }
        }
    }

    private void ShowSessionSettingsDialog(Guid sessionId)
    {
        settingsSessionId = sessionId;
        showSessionSettingsDialog = true;
    }

    private async Task OnSessionSettingsSaved()
    {
        showSessionSettingsDialog = false;
        // セッション一覧を更新
        sessions = SessionManager.GetAllSessions().ToList();
        await LocalStorageService.SaveSessionsAsync(sessions);
        
        // セッションが再起動された場合、ターミナルコンポーネントも再読み込み
        if (settingsSessionId.HasValue && settingsSessionId.Value == activeSessionId)
        {
            var sessionId = settingsSessionId.Value;
            
            
            // 一旦nullにして再選択することで、ターミナルコンポーネントを再作成
            activeSessionId = null;
            activeSession = null;
            StateHasChanged();
            await Task.Delay(100); // UIの更新を待つ
            await SelectSession(sessionId);
        }
        else
        {
            StateHasChanged();
        }
        
        toast?.ShowSuccess("セッション設定を保存しました");
    }
    
    private async Task RefreshGitStatus(Guid sessionId)
    {
        var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionInfo != null && sessionInfo.IsGitRepository)
        {
            // Gitステータスを更新
            var gitInfo = await GitService.GetGitInfoAsync(sessionInfo.FolderPath);
            if (gitInfo != null)
            {
                sessionInfo.GitBranch = gitInfo.CurrentBranch;
                sessionInfo.HasUncommittedChanges = gitInfo.HasUncommittedChanges;
                sessionInfo.IsWorktree = gitInfo.IsWorktree;
                
                await LocalStorageService.SaveSessionsAsync(sessions);
                StateHasChanged();
            }
        }
    }

    private async Task RestartSessionWithoutContinue(Guid sessionId)
    {
        var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionInfo == null)
        {
            // Session info not found
            return;
        }

        try
        {
            // Restarting session without --continue
            
            
            // セッションを再起動（HasContinueErrorOccurredフラグにより--continueは自動的に除外される）
            var success = await SessionManager.RestartSessionAsync(sessionId);
            if (success)
            {
                // セッション一覧を更新
                sessions = SessionManager.GetAllSessions().ToList();
                
                // ローカルストレージに保存
                await LocalStorageService.SaveSessionsAsync(sessions);
                
                // 強制的にセッションを再初期化するため、一旦nullにする
                activeSessionId = null;
                activeSession = null;
                StateHasChanged();
                await Task.Delay(100); // UIの更新を待つ
                
                // 再起動後のセッションを選択
                await SelectSession(sessionId);
                
                toast?.ShowInfo("--continueオプションなしでセッションを再起動しました");
            }
            else
            {
                // Session restart failed
                toast?.ShowError("セッション再起動に失敗しました");
            }
        }
        catch (Exception ex)
        {
            // RestartSessionWithoutContinue error
            toast?.ShowError($"セッション再起動エラー: {ex.Message}");
        }
    }
    
    private void SetupSessionEventHandlers(SessionInfo sessionInfo)
    {
        if (sessionInfo?.ConPtySession == null)
        {
            Console.WriteLine($"[SetupSessionEventHandlers] ConPtySessionがnullのためスキップ: {sessionInfo?.SessionId}");
            return;
        }
            
        Console.WriteLine($"[SetupSessionEventHandlers] イベントハンドラー設定: {sessionInfo.SessionId}");
        
        // ConPtySessionはイベントハンドラーのクリアが不要
        
        // データ受信イベントハンドラー
        sessionInfo.ConPtySession.DataReceived += async (sender, args) =>
        {
            try
            {
                await ProcessReceivedData(sessionInfo.SessionId, args.Data);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[DataReceived] エラー: {ex.Message}");
            }
        };
        
        // 切断イベントハンドラー
        sessionInfo.ConPtySession.ProcessExited += (sender, args) =>
        {
            Console.WriteLine($"[ProcessExited] セッション切断検出: {sessionInfo.SessionId}");
        };
    }
    
    // タスクランナー関連メソッド
    private async Task LoadNpmScripts()
    {
        if (activeSessionId == null) return;
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) return;
        
        Console.WriteLine($"[LoadNpmScripts] Loading scripts from: {currentSession.FolderPath}");
        npmScripts = await PackageJsonService.GetNpmScriptsAsync(currentSession.FolderPath);
        Console.WriteLine($"[LoadNpmScripts] Scripts loaded: {npmScripts?.Count ?? 0} (null: {npmScripts == null})");
        
        selectedScript = null;
        StateHasChanged();
    }
    
    private void SelectScript(string scriptName)
    {
        selectedScript = scriptName;
    }
    
    private void ToggleScriptCheck(string scriptName)
    {
        if (activeSessionId == null) return;
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) return;
        
        if (currentSession.CheckedScripts.Contains(scriptName))
        {
            currentSession.CheckedScripts.Remove(scriptName);
        }
        else
        {
            currentSession.CheckedScripts.Add(scriptName);
        }
        
        // グローバルのcheckedScriptsも更新
        checkedScripts = new HashSet<string>(currentSession.CheckedScripts);
        StateHasChanged();
        
        // セッション情報を保存
        _ = LocalStorageService.SaveSessionsAsync(sessions);
    }
    
    private async Task InitializeTaskRunnerTerminal()
    {
        try
        {
            Console.WriteLine($"[InitializeTaskRunnerTerminal] 初期化開始 - taskRunnerTerminal: {(taskRunnerTerminal != null ? "存在" : "null")}");
            if (taskRunnerTerminal != null)
            {
                Console.WriteLine("[InitializeTaskRunnerTerminal] 既に初期化済みのためスキップ");
                return;
            }
            
            // DOM要素の存在を確認
            var elementExists = await JSRuntime.InvokeAsync<bool>("eval", @"
                !!document.getElementById('task-runner-terminal')
            ");
            
            Console.WriteLine($"[InitializeTaskRunnerTerminal] DOM要素確認 - elementExists: {elementExists}");
            
            if (!elementExists)
            {
                Console.WriteLine("[InitializeTaskRunnerTerminal] DOM要素がないためStateHasChangedと200ms待機");
                StateHasChanged();
                await Task.Delay(200); // DOM更新を待つ
                
                // 再度確認
                elementExists = await JSRuntime.InvokeAsync<bool>("eval", @"
                    !!document.getElementById('task-runner-terminal')
                ");
                Console.WriteLine($"[InitializeTaskRunnerTerminal] DOM要素再確認 - elementExists: {elementExists}");
            }
            
            // 新しいXTermを作成
            Console.WriteLine("[InitializeTaskRunnerTerminal] createMultiSessionTerminalを呼び出し");
            taskRunnerTerminal = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "terminalFunctions.createMultiSessionTerminal",
                "task-runner-terminal",
                "task-runner-terminal",
                dotNetRef
            );
            
            Console.WriteLine($"[InitializeTaskRunnerTerminal] ターミナル作成完了 - taskRunnerTerminal: {(taskRunnerTerminal != null ? "成功" : "失敗")}");
            
            // 初期メッセージを表示
            await taskRunnerTerminal.InvokeVoidAsync("write", "タスクランナーターミナル準備完了\r\n");
            Console.WriteLine("[InitializeTaskRunnerTerminal] 初期メッセージ表示完了");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[InitializeTaskRunnerTerminal] エラー: {ex.Message}");
            toast?.ShowError($"タスクランナーターミナルの初期化エラー: {ex.Message}");
        }
    }
    
    private async Task CleanupTaskRunnerTerminal()
    {
        try
        {
            Console.WriteLine($"[CleanupTaskRunnerTerminal] クリーンアップ開始 - taskRunnerTerminal: {(taskRunnerTerminal != null ? "存在" : "null")}, TaskRunnerInitialized: {TaskRunnerInitialized}");
            Console.WriteLine("[CleanupTaskRunnerTerminal] 呼び出し元のスタックトレース:");
            Console.WriteLine(Environment.StackTrace);
            
            if (taskRunnerTerminal != null)
            {
                // JavaScript側で破棄
                await JSRuntime.InvokeVoidAsync("eval", @"
                    (function() {
                        const terminalId = 'task-runner-terminal';
                        const termObj = window.multiSessionTerminals && window.multiSessionTerminals[terminalId];
                        if (termObj) {
                            termObj.terminal.dispose();
                            delete window.multiSessionTerminals[terminalId];
                        }
                    })()
                ");
                
                await taskRunnerTerminal.DisposeAsync();
                taskRunnerTerminal = null;
                TaskRunnerInitialized = false;
            }
            
            // ConPTYセッションがあれば破棄
            taskRunnerSession?.Dispose();
            taskRunnerSession = null;
            
            Console.WriteLine("[CleanupTaskRunnerTerminal] クリーンアップ完了 - taskRunnerTerminal=null, TaskRunnerInitialized=false");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[CleanupTaskRunnerTerminal] エラー: {ex.Message}");
        }
    }
    
    private async Task RunSelectedScript()
    {
        Console.WriteLine($"[RunSelectedScript] 開始 - selectedScript: {selectedScript}, activeSessionId: {activeSessionId}");
        
        if (string.IsNullOrEmpty(selectedScript) || activeSessionId == null)
        {
            Console.WriteLine("[RunSelectedScript] selectedScriptまたはactiveSessionIdがnullのため中断");
            return;
        }
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null)
        {
            Console.WriteLine("[RunSelectedScript] currentSessionが見つからないため中断");
            return;
        }
        
        try
        {
            Console.WriteLine($"[RunSelectedScript] スクリプト実行開始: {selectedScript}");
            runningScripts.Add(selectedScript);
            StateHasChanged();
            
            // 既存のConPTYセッションがあれば破棄
            Console.WriteLine($"[RunSelectedScript] 既存のtaskRunnerSessionを破棄: {(taskRunnerSession != null ? "存在" : "null")}");
            if (taskRunnerSession != null)
            {
                try
                {
                    taskRunnerSession.Dispose();
                    Console.WriteLine("[RunSelectedScript] 既存セッションの破棄完了");
                }
                catch (Exception disposeEx)
                {
                    Console.WriteLine($"[RunSelectedScript] 既存セッション破棄エラー: {disposeEx.Message}");
                }
                taskRunnerSession = null;
            }
            
            // npm run [script] コマンドを実行
            var command = $"npm run {selectedScript}";
            Console.WriteLine($"[RunSelectedScript] ConPTYセッション作成開始 - フォルダ: {currentSession.FolderPath}");
            Console.WriteLine($"[RunSelectedScript] ConPtyService: {(ConPtyService != null ? "存在" : "null")}");
            
            ConPtySession? conPtySession = null;
            try
            {
                var folderPath = currentSession.FolderPath ?? Environment.CurrentDirectory;
                Console.WriteLine($"[RunSelectedScript] FolderPath: {folderPath}");
                conPtySession = await ConPtyService.CreateSessionAsync("cmd.exe", null, folderPath, 120, 30);
                Console.WriteLine($"[RunSelectedScript] CreateSessionAsync完了 - conPtySession: {(conPtySession != null ? "存在" : "null")}");
            }
            catch (Exception createEx)
            {
                Console.WriteLine($"[RunSelectedScript] CreateSessionAsyncエラー: {createEx.GetType().Name} - {createEx.Message}");
                Console.WriteLine($"[RunSelectedScript] スタックトレース: {createEx.StackTrace}");
                throw;
            }
            
            if (conPtySession == null)
            {
                Console.WriteLine("[RunSelectedScript] エラー: ConPTYセッションの作成に失敗");
                runningScripts.Remove(selectedScript);
                toast?.ShowError("ターミナルセッションの作成に失敗しました");
                return;
            }
            
            taskRunnerSession = conPtySession;
            Console.WriteLine("[RunSelectedScript] ConPTYセッション作成成功");
            conPtySession.Start();
            taskRunnerSession.DataReceived += (sender, args) => OnTaskRunnerDataReceived(args.Data);
            taskRunnerSession.ProcessExited += (sender, args) => OnTaskRunnerExited(selectedScript);
            
            // ターミナルをクリアして実行コマンドを表示
            Console.WriteLine($"[RunSelectedScript] taskRunnerTerminal: {(taskRunnerTerminal != null ? "存在" : "null")}");
            if (taskRunnerTerminal != null && taskRunnerSession != null)
            {
                Console.WriteLine("[RunSelectedScript] ターミナルをクリア");
                await taskRunnerTerminal.InvokeVoidAsync("clear");
                Console.WriteLine($"[RunSelectedScript] コマンドを表示: > {command}");
                await taskRunnerTerminal.InvokeVoidAsync("write", $"> {command}\r\n");
                
                // コマンドを実行
                Console.WriteLine($"[RunSelectedScript] ConPTYにコマンド送信: {command}");
                Console.WriteLine($"[RunSelectedScript] taskRunnerSession再確認: {(taskRunnerSession != null ? "存在" : "null")}");
                if (taskRunnerSession != null)
                {
                    await taskRunnerSession.WriteAsync($"{command}\r");
                    Console.WriteLine("[RunSelectedScript] コマンド送信完了");
                }
                else
                {
                    Console.WriteLine("[RunSelectedScript] エラー: taskRunnerSessionがnullのためコマンド送信できません");
                    throw new InvalidOperationException("taskRunnerSession is null after initialization");
                }
            }
            else
            {
                Console.WriteLine("[RunSelectedScript] 警告: taskRunnerTerminalがnull");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[RunSelectedScript] エラー発生: {ex.GetType().Name} - {ex.Message}");
            Console.WriteLine($"[RunSelectedScript] スタックトレース: {ex.StackTrace}");
            runningScripts.Remove(selectedScript);
            toast?.ShowError($"スクリプト実行エラー: {ex.Message}");
            StateHasChanged();
        }
    }
    
    private async Task StopSelectedScript()
    {
        if (string.IsNullOrEmpty(selectedScript)) return;
        
        // ConPTYセッションを停止
        taskRunnerSession?.Dispose();
        taskRunnerSession = null;
        
        runningScripts.Remove(selectedScript);
        StateHasChanged();
        
        if (taskRunnerTerminal != null)
        {
            await taskRunnerTerminal.InvokeVoidAsync("write", "\r\n\x1b[91mタスクを停止しました\x1b[0m\r\n");
        }
    }
    
    private async void OnTaskRunnerDataReceived(string data)
    {
        if (taskRunnerTerminal != null)
        {
            await InvokeAsync(async () =>
            {
                await taskRunnerTerminal.InvokeVoidAsync("write", data);
            });
        }
    }
    
    private void OnTaskRunnerExited(string scriptName)
    {
        InvokeAsync(async () =>
        {
            runningScripts.Remove(scriptName);
            taskRunnerSession?.Dispose();
            taskRunnerSession = null;
            
            if (taskRunnerTerminal != null)
            {
                await taskRunnerTerminal.InvokeVoidAsync("write", "\r\n\x1b[92mタスクが完了しました\x1b[0m\r\n");
            }
            
            StateHasChanged();
        });
    }
    
    private async void OnTaskButtonClick(string scriptName)
    {
        Console.WriteLine($"[UI] タスク実行ボタンクリック: {scriptName}");
        await RunScriptFromTextInput(scriptName);
    }
    
    private async Task RunScriptFromTextInput(string scriptName)
    {
        Console.WriteLine($"[RunScriptFromTextInput] 開始 - scriptName: {scriptName}, activeSessionId: {activeSessionId}");
        
        if (activeSessionId == null) return;
        
        var sessionId = activeSessionId.Value; // 値をキャプチャ
        
        // タスクランナータブに切り替え
        Console.WriteLine("[RunScriptFromTextInput] タスクランナータブに切り替え");
        await SwitchBottomPanelTab(BottomPanelTab.TaskRunner);
        
        // DOM更新を待つ
        await Task.Delay(200);
        
        // セッションが変わっていないか確認
        if (activeSessionId != sessionId)
        {
            Console.WriteLine("[RunScriptFromTextInput] セッションが変更されたため中断");
            return;
        }
        
        // スクリプトを選択して実行
        Console.WriteLine($"[RunScriptFromTextInput] スクリプト実行: {scriptName}");
        selectedScript = scriptName;
        await RunSelectedScript();
    }
    
    public async ValueTask DisposeAsync()
    {
        // OutputAnalyzerServiceのクリーンアップ
        OutputAnalyzerService?.Dispose();
        
        // JavaScript interopを安全に処理
        try
        {
            // 履歴を保存（JavaScript interopを使用）
            await InputHistoryService.SaveHistoryAsync();
        }
        catch (JSDisconnectedException)
        {
            // 回路が切断されている場合は無視
        }
        catch (Exception)
        {
            // その他のエラーも無視
        }
        
        // 単一DOSターミナルのクリーンアップ
        await CleanupSingleDosTerminal();
        
        // タスクランナーターミナルのクリーンアップ
        await CleanupTaskRunnerTerminal();
        
        // 全セッションのDOS ConPTYセッションのクリーンアップ
        foreach (var session in sessions)
        {
            session.DosTerminalConPtySession?.Dispose();
        }
        
        // activeTerminalのDisposeを安全に処理
        if (activeTerminal != null)
        {
            try
            {
                await activeTerminal.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // 回路が切断されている場合は無視
            }
            catch (Exception)
            {
                // その他のエラーも無視
            }
        }
        
        dotNetRef?.Dispose();
        
        // JavaScriptのイベントリスナーをクリーンアップ
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupKeyboardShortcuts");
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupDevWindowDrag");
        }
        catch (JSDisconnectedException)
        {
            // 回路が切断されている場合は無視
        }
        catch (Exception)
        {
            // Dispose時のエラーは無視
        }
    }
}
