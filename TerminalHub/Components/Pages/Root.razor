@page "/multisession"
@page "/"
@using TerminalHub.Components.Shared
@using TerminalHub.Components.Shared.Dialogs
@using TerminalHub.Components.Shared.BottomPanels
@using TerminalHub.Constants
@using TerminalHub.Models
@using TerminalHub.Services
@using TerminalHub.Analyzers
@using Microsoft.JSInterop
@using Microsoft.Extensions.Configuration
@using Microsoft.Extensions.Logging
@using TaskStatus = TerminalHub.Models.TaskStatus
@inject ISessionManager SessionManager
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorageService
@inject IConfiguration Configuration
@inject INotificationService NotificationService
@inject IOutputAnalyzerFactory AnalyzerFactory
@inject IGitService GitService
@inject ITerminalService TerminalService
@inject IOutputAnalyzerService OutputAnalyzerService
@inject IInputHistoryService InputHistoryService
@inject IPackageJsonService PackageJsonService
@inject IConPtyService ConPtyService
@inject ITaskManagerService TaskManagerService
@inject ConPtyConnectionService ConPtyConnection
@inject ILogger<Root> Logger
@inject ILoggerFactory LoggerFactory
@inject IHookNotificationService HookNotificationService
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>マルチセッション ターミナル</PageTitle>

<Toast @ref="toast" />
<SessionCreateDialog IsVisible="showCreateDialog" 
                    OnSessionCreate="OnSessionCreate" 
                    OnCancel="OnDialogCancel" />
<SettingsDialog @bind-IsVisible="showSettingsDialog"
                OnSessionSortModeChanged="HandleSessionSortModeChanged" />
<SubSessionDialog IsVisible="showSubSessionDialog" 
                         ParentSessionName="@subSessionParentSessionName"
                         ParentSessionId="@subSessionParentSessionId"
                         ParentSessionPath="@subSessionParentSessionPath"
                         IsGitRepository="@subSessionParentSessionIsGitRepository"
                         OnSubSessionOperation="OnSubSessionOperation" 
                         OnCancel="() => showSubSessionDialog = false" />
<SessionSettingsDialog IsVisible="showSessionSettingsDialog"
                       SessionId="@settingsSessionId"
                       OnSettingsSaved="OnSessionSettingsSaved"
                       OnCancel="() => showSessionSettingsDialog = false" />
<ArchivedSessionsDialog IsVisible="showArchivedSessionsDialog"
                        ArchivedSessions="@GetArchivedSessions()"
                        OnRestoreSession="RestoreArchivedSession"
                        OnDeleteSession="DeleteArchivedSession"
                        OnDeleteAllSessions="DeleteAllArchivedSessions"
                        OnClose="() => showArchivedSessionsDialog = false" />

<div class="container-fluid h-100">
    <div class="row h-100">
        <SessionList Sessions=@sessions
                     ActiveSessionId=@activeSessionId
                     IsAddingSession=@isAddingSession
                     SortMode=@sessionSortMode
                     OnAddSession="AddSession"
                     OnSessionSelect="async (sessionId) => await SelectSession(sessionId)"
                     OnSessionRemove="async (sessionId) => await ArchiveSession(sessionId)"
                     OnSettingsClick="ShowSettings"
                     OnCreateWorktree="ShowWorktreeDialog"
                     OnSessionSettings="ShowSessionSettingsDialog"
                     OnGitStatusRefresh="RefreshGitStatus"
                     OnSessionExpandedChanged="HandleSessionExpandedChanged"
                     OnShowArchivedSessions="() => showArchivedSessionsDialog = true" />

        <div class="col-md-9 p-0 position-relative" style="height: 100vh; display: flex; flex-direction: column;">
            @if (activeSessionId != null)
            {
                <!-- ターミナル部分 (70%) -->
                <div style="height: 70%; overflow: hidden;">
                    <div class="terminal-wrapper h-100">
                        @foreach (var session in sessions)
                        {
                            <div id="terminal-@session.SessionId" class="terminal-container" 
                                 style="display: @(session.SessionId == activeSessionId ? "block" : "none");"></div>
                        }
                    </div>
                </div>
                
                <!-- WebUI部分 (30%) -->
                <div style="height: 30%; border-top: 1px solid #dee2e6; background-color: #f8f9fa; display: flex; flex-direction: column;">
                    @{
                        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
                    }
                    @if (currentSession != null)
                    {
                        <!-- タブヘッダー -->
                        <ul class="nav nav-tabs px-3 pt-2" style="flex-shrink: 0;">
                            @foreach (var tab in bottomPanelTabs)
                            {
                                <li class="nav-item">
                                    <a class="nav-link @(activeBottomPanelTabId == tab.Id ? "active" : "") d-flex align-items-center gap-1"
                                       href="#"
                                       @onclick:preventDefault="true"
                                       @onclick="async () => await SelectBottomPanelTab(tab.Id)">
                                        <i class="bi @GetBottomPanelTabIcon(tab.Type)"></i>
                                        <span>@tab.DisplayName</span>
                                        @if (!tab.IsDefault)
                                        {
                                            <button type="button" class="btn-close btn-close-white ms-1" style="font-size: 0.6rem; opacity: 0.7;"
                                                    @onclick:preventDefault="true"
                                                    @onclick:stopPropagation="true"
                                                    @onclick="async () => await RemoveBottomPanelTab(tab.Id)"
                                                    title="タブを閉じる">
                                            </button>
                                        }
                                    </a>
                                </li>
                            }
                            <!-- タブ追加ドロップダウン -->
                            <li class="nav-item dropdown">
                                <a class="nav-link dropdown-toggle" href="#" data-bs-toggle="dropdown" @onclick:preventDefault="true">
                                    <i class="bi bi-plus-lg"></i>
                                </a>
                                <ul class="dropdown-menu">
                                    <li>
                                        <a class="dropdown-item" href="#" @onclick:preventDefault="true"
                                           @onclick="async () => await AddBottomPanelTab(BottomPanelTabType.TextInput)">
                                            <i class="bi bi-chat-left-text me-2"></i>テキスト入力を追加
                                        </a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="#" @onclick:preventDefault="true"
                                           @onclick="async () => await AddBottomPanelTab(BottomPanelTabType.DosTerminal)">
                                            <i class="bi bi-terminal me-2"></i>DOSターミナルを追加
                                        </a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        
                        <!-- タブコンテンツ -->
                        <div class="flex-grow-1" style="overflow-y: auto;">
                            @{
                                var activeTab = bottomPanelTabs.FirstOrDefault(t => t.Id == activeBottomPanelTabId);
                            }
                            @if (activeTab != null)
                            {
                                @if (activeTab.Type == BottomPanelTabType.TextInput)
                                {
                                    <TextInputPanel PanelId="@activeTab.Id"
                                                    TerminalType="@currentSession.TerminalType"
                                                    ClaudeModeSwitchKey="@claudeModeSwitchKey"
                                                    PlaceholderText="@GetPlaceholderText(currentSession.TerminalType)"
                                                    Text="@GetTextInputPanelText(activeTab.Id)"
                                                    TextChanged="@(text => SetTextInputPanelText(activeTab.Id, text))"
                                                    OnSendInput="HandleTextInputSend"
                                                    OnCtrlC="SendCtrlC"
                                                    OnEscape="SendEscape"
                                                    OnModeSwitch="SendModeSwitch" />
                                }
                                else if (activeTab.Type == BottomPanelTabType.DosTerminal)
                                {
                                    <DosTerminalPanel @ref="currentDosTerminalPanelRef"
                                                      PanelId="@activeTab.Id"
                                                      WorkingDirectory="@currentSession.FolderPath"
                                                      DotNetRef="@dotNetRef" />
                                }
                            }
                            @if (bottomPanelTab == BottomPanelTab.TaskRunner)
                            {
                                <div class="h-100 p-3 d-flex">
                                    <!-- npm scripts一覧 (30%) -->
                                    <div style="width: 30%; overflow-y: auto; padding-right: 1rem;">
                                        <h6 class="mb-3">NPM Scripts</h6>
                                        @if (npmScripts != null && npmScripts.Count > 0)
                                        {
                                            <div class="list-group">
                                                @foreach (var script in npmScripts)
                                                {
                                                    var taskSession = GetTaskSessionByScriptName(script.Key);
                                                    <div class="list-group-item" 
                                                         style="cursor: pointer; @(selectedScript == script.Key ? "background-color: #e7f1ff; border-color: #0d6efd; border-width: 2px;" : "")"
                                                         @onclick="() => SelectScript(script.Key)">
                                                        <div class="d-flex justify-content-between align-items-start mb-2">
                                                            <div class="d-flex align-items-start flex-grow-1">
                                                                <input type="checkbox" 
                                                                       class="form-check-input me-2" 
                                                                       id="@($"script-check-{script.Key}")"
                                                                       checked="@checkedScripts.Contains(script.Key)"
                                                                       @onchange="() => ToggleScriptCheck(script.Key)"
                                                                       @onclick:stopPropagation="true" />
                                                                <div class="flex-grow-1">
                                                                    <label for="@($"script-check-{script.Key}")" class="mb-0">
                                                                        <strong>@script.Key</strong>
                                                                    </label>
                                                                    <div class="small text-muted" style="white-space: pre-wrap;">@script.Value</div>
                                                                    @if (taskSession != null)
                                                                    {
                                                                        <div class="d-flex align-items-center gap-2 mt-1">
                                                                            <span class="@taskSession.StatusCssClass">@taskSession.StatusText</span>
                                                                            @if (taskSession.Duration != null)
                                                                            {
                                                                                <span class="small text-muted">@($"{taskSession.Duration.Value.TotalSeconds:F1}秒")</span>
                                                                            }
                                                                        </div>
                                                                    }
                                                                </div>
                                                            </div>
                                                            <div class="d-flex align-items-center gap-1">
                                                                @if (taskSession?.Status == TaskStatus.Running)
                                                                {
                                                                    <span class="spinner-border spinner-border-sm text-primary" role="status">
                                                                        <span class="visually-hidden">Loading...</span>
                                                                    </span>
                                                                }
                                                                @if (taskSession?.IsTerminalConnected == true)
                                                                {
                                                                    <i class="bi bi-terminal text-info" title="ターミナル接続中"></i>
                                                                }
                                                            </div>
                                                        </div>
                                                        @if (selectedScript == script.Key)
                                                        {
                                                            <div class="d-flex gap-1 flex-wrap mt-2">
                                                                @if (taskSession == null)
                                                                {
                                                                    <!-- タスクがまだ作成されていない -->
                                                                    <button class="btn btn-primary btn-sm" 
                                                                            @onclick="() => RunTaskWithTerminal(script.Key)" 
                                                                            @onclick:stopPropagation="true"
                                                                            title="実行（ターミナル表示）">
                                                                        <i class="bi bi-play-circle"></i> 実行
                                                                    </button>
                                                                }
                                                                else if (taskSession.Status == TaskStatus.Idle)
                                                                {
                                                                    <!-- タスクは作成済みだが未実行（実行のみで作成された） -->
                                                                    
                                                                    <button class="btn btn-danger btn-sm" 
                                                                            @onclick="StopSelectedScript" 
                                                                            @onclick:stopPropagation="true"
                                                                            title="タスクを破棄">
                                                                        <i class="bi bi-trash"></i> 破棄
                                                                    </button>
                                                                }
                                                                else if (taskSession.Status == TaskStatus.Running)
                                                                {
                                                                    <!-- タスク実行中 -->
                                                                    <button class="btn btn-danger btn-sm" 
                                                                            @onclick="StopSelectedScript" 
                                                                            @onclick:stopPropagation="true"
                                                                            title="タスクを停止">
                                                                        <i class="bi bi-stop-circle"></i> 停止
                                                                    </button>
                                                                    
                                                                }
                                                                else
                                                                {
                                                                    <!-- タスク完了/失敗/停止済み - 再実行可能 -->
                                                                    <button class="btn btn-primary btn-sm" 
                                                                            @onclick="() => RunTaskWithTerminal(script.Key)" 
                                                                            @onclick:stopPropagation="true"
                                                                            title="実行（ターミナル表示）">
                                                                        <i class="bi bi-play-circle"></i> 再実行
                                                                    </button>
                                                                    
                                                                    <button class="btn btn-secondary btn-sm" 
                                                                            @onclick="() => RunTaskBackground(script.Key)" 
                                                                            @onclick:stopPropagation="true"
                                                                            title="バックグラウンド実行">
                                                                        <i class="bi bi-play"></i> 実行のみ
                                                                    </button>
                                                                    
                                                                    @if (taskSession.Status == TaskStatus.Completed)
                                                                    {
                                                                        <span class="badge bg-success ms-2">完了</span>
                                                                    }
                                                                    else if (taskSession.Status == TaskStatus.Failed)
                                                                    {
                                                                        <span class="badge bg-danger ms-2">失敗</span>
                                                                    }
                                                                    else if (taskSession.Status == TaskStatus.Stopped)
                                                                    {
                                                                        <span class="badge bg-warning ms-2">停止</span>
                                                                    }
                                                                }
                                                            </div>
                                                        }
                                                    </div>
                                                }
                                            </div>
                                        }
                                        else
                                        {
                                            <div class="alert alert-info">
                                                <i class="bi bi-info-circle"></i> npm scriptsが見つかりません
                                            </div>
                                        }
                                    </div>
                                    
                                    <!-- タスク実行ターミナル (70%) -->
                                    <div style="width: 70%; padding-left: 1rem; border-left: 1px solid #dee2e6;">
                                        <div class="h-100" id="task-runner-terminal" style="background-color: #000; width: 100%; height: 100%;">
                                            <!-- タスクランナー用ターミナル -->
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="d-flex align-items-center justify-content-center h-100">
                    <div class="text-center text-muted">
                        <i class="bi bi-terminal" style="font-size: 4rem;"></i>
                        <p class="mt-3">左側からセッションを選択してください</p>
                    </div>
                </div>
            }
        </div>
    </div>
</div>


@code {
    private List<SessionInfo> sessions = new();
    private Guid? activeSessionId;
    private bool isAddingSession = false;
    private string sessionSortMode = "createdAt"; // セッション一覧のソートモード
    private bool showCreateDialog = false;
    private IJSObjectReference? activeTerminal;
    private ConPtySession? activeSession;

    private DotNetObjectReference<Root>? dotNetRef;
    private Toast? toast;
    private string inputText = "";
    private BottomPanelTab bottomPanelTab = BottomPanelTab.TextInput; // デフォルトはテキスト入力タブ（互換性維持）
    private IJSObjectReference? singleDosTerminal; // 単一のDOSターミナルXTermインスタンス
    private Guid? currentDosTerminalSessionId; // 現在DOSターミナルに接続しているセッションID

    // 動的下部パネルタブ
    private List<BottomPanelTabInfo> bottomPanelTabs = new();
    private string activeBottomPanelTabId = "default-text";
    private Dictionary<string, DosTerminalPanel> dosTerminalPanelRefs = new();
    private DosTerminalPanel? currentDosTerminalPanelRef;
    private Dictionary<string, string> textInputPanelTexts = new();
    private bool showSettingsDialog = false;
    private bool showSubSessionDialog = false;
    private string? subSessionParentSessionName = null;
    private Guid? subSessionParentSessionId = null;
    private string? subSessionParentSessionPath = null;
    private bool subSessionParentSessionIsGitRepository = true;
    private bool showSessionSettingsDialog = false;
    private Guid? settingsSessionId = null;
    private bool showArchivedSessionsDialog = false;

    // タスクランナー関連
    private bool hasPackageJson = false;
    private Dictionary<string, string>? npmScripts = null;
    private string? selectedScript = null;
    private HashSet<string> checkedScripts = new HashSet<string>();
    private IJSObjectReference? taskRunnerTerminal;
    private bool TaskRunnerInitialized = false;
    private TaskSession? currentTaskSession => TaskManagerService.ActiveSession;

    // TaskManagerServiceイベントハンドラー
    private EventHandler<string>? _taskDataReceivedHandler;
    private EventHandler<TaskSession>? _taskSessionUpdatedHandler;

    // HookNotificationServiceイベントハンドラー
    private EventHandler<HookNotificationEventArgs>? _hookNotificationHandler;

    // SessionManagerイベントハンドラー
    private EventHandler? _sessionsChangedHandler;

    // DOSターミナルイベントハンドラー（セッションごと）
    private readonly Dictionary<Guid, (EventHandler<DataReceivedEventArgs> DataReceived, EventHandler ProcessExited)> _dosTerminalHandlers = new();

    // スナップショット設定
    private int _defaultSnapshotLines = 50;
    private int _recreateSnapshotLines = 100;


    protected override Task OnInitializedAsync()
    {
        dotNetRef = DotNetObjectReference.Create(this);

        // スナップショット設定を読み込み
        _defaultSnapshotLines = Configuration.GetValue<int>("TerminalSettings:DefaultSnapshotLines", 50);
        _recreateSnapshotLines = Configuration.GetValue<int>("TerminalSettings:RecreateSnapshotLines", 100);



        // OutputAnalyzerServiceのタイムアウトコールバックを設定
        OutputAnalyzerService.SetTimeoutCallback(sessionId =>
        {
            _ = InvokeAsync(async () => await OnSessionTimeout(sessionId));
        });

        // TaskManagerServiceのイベントハンドラーを設定
        _taskDataReceivedHandler = (sender, data) =>
        {
            InvokeAsync(async () =>
            {
                // アクティブセッションがターミナル接続されている場合のみ表示
                if (taskRunnerTerminal != null && TaskManagerService.ActiveSession?.IsTerminalConnected == true)
                {
                    try
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", data);
                    }
                    catch (JSDisconnectedException)
                    {
                        // 回路が切断されている場合は無視
                    }
                    catch (Exception)
                    {
                        // その他のエラーも無視
                    }
                }
            });
        };
        TaskManagerService.SessionDataReceived += _taskDataReceivedHandler;

        _taskSessionUpdatedHandler = (sender, taskSession) =>
        {
            InvokeAsync(() => StateHasChanged());
        };
        TaskManagerService.SessionUpdated += _taskSessionUpdatedHandler;

        // HookNotificationServiceのイベントハンドラーを設定
        _hookNotificationHandler = (sender, args) =>
        {
            _ = InvokeAsync(async () => await OnHookNotification(args.Notification));
        };
        HookNotificationService.OnHookNotification += _hookNotificationHandler;

        // SessionManagerのセッション変更イベントを購読
        _sessionsChangedHandler = (sender, args) =>
        {
            InvokeAsync(() => OnSessionsChanged());
        };
        SessionManager.OnSessionsChanged += _sessionsChangedHandler;

        // JavaScript interopはOnAfterRenderAsyncで実行
        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // キーボードショートカットを登録
            try
            {
                await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setupKeyboardShortcuts", dotNetRef);
                // 通知用のDotNetRefを設定
                await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setDotNetRef", dotNetRef);
            }
            catch (JSDisconnectedException)
            {
                // 回路が切断されている場合は無視
            }
            catch (Exception)
            {
                // その他のエラーも無視
            }

            // テキスト履歴を読み込み
            await InputHistoryService.LoadHistoryAsync();

            // 特殊設定を読み込み
            try
            {
                var specialSettings = await JSRuntime.InvokeAsync<System.Text.Json.JsonElement?>("terminalHubHelpers.getSpecialSettings");
                if (specialSettings.HasValue && specialSettings.Value.TryGetProperty("claudeModeSwitchKey", out var key))
                {
                    claudeModeSwitchKey = key.GetString() ?? "altM";
                }
            }
            catch
            {
                // エラー時はデフォルト値を使用
            }

            // セッション設定を読み込み
            try
            {
                var sessionSettings = await JSRuntime.InvokeAsync<System.Text.Json.JsonElement?>("terminalHubHelpers.getSessionSettings");
                if (sessionSettings.HasValue && sessionSettings.Value.TryGetProperty("sortMode", out var sortMode))
                {
                    sessionSortMode = sortMode.GetString() ?? "createdAt";
                }
            }
            catch
            {
                // エラー時はデフォルト値を使用
            }

            // 下部パネルタブを初期化
            await InitializeBottomPanelTabs();

            // SessionManagerにセッションが存在するかチェック
            // 存在する場合は他のブラウザが既に起動しているため、LocalStorageからの読み込みはスキップ
            var sessionsToPopulateGitInfo = new List<Guid>();

            if (!SessionManager.HasSessions())
            {
                // SessionManagerが空の場合のみLocalStorageから復元
                var savedSessions = await LocalStorageService.LoadSessionsAsync();

                foreach (var sessionInfo in savedSessions)
                {
                    // アーカイブされたセッションはSessionManagerに直接追加
                    if (sessionInfo.IsArchived)
                    {
                        SessionManager.AddArchivedSession(sessionInfo);
                        continue;
                    }

                    // 重複チェック（ホットリロード対策）
                    var existingSession = SessionManager.GetSessionInfo(sessionInfo.SessionId);
                    if (existingSession != null)
                    {
                        continue;
                    }

                    // セッションを再作成（Git情報はスキップして高速化）
                    try
                    {
                        var newSession = await SessionManager.CreateSessionAsync(
                            sessionInfo.SessionId,
                            sessionInfo.FolderPath,
                            sessionInfo.DisplayName ?? "",
                            sessionInfo.TerminalType,
                            sessionInfo.Options,
                            skipGitInfo: true);  // Git情報をスキップ

                        // メモ情報と親子関係を復元
                        var createdSession = SessionManager.GetSessionInfo(newSession.SessionId);
                        if (createdSession != null)
                        {
                            // 作成日時と最終利用日時を復元
                            createdSession.CreatedAt = sessionInfo.CreatedAt;
                            createdSession.LastAccessedAt = sessionInfo.LastAccessedAt;

                            if (!string.IsNullOrEmpty(sessionInfo.Memo))
                            {
                                createdSession.Memo = sessionInfo.Memo;
                            }

                            // チェックされたスクリプトを復元
                            if (sessionInfo.CheckedScripts != null && sessionInfo.CheckedScripts.Count > 0)
                            {
                                createdSession.CheckedScripts = new HashSet<string>(sessionInfo.CheckedScripts);
                            }

                            // 親子関係を復元
                            if (sessionInfo.ParentSessionId.HasValue)
                            {
                                createdSession.ParentSessionId = sessionInfo.ParentSessionId;
                            }

                            await SessionManager.SaveSessionInfoAsync(createdSession);
                        }

                        sessionsToPopulateGitInfo.Add(newSession.SessionId);
                    }
                    catch (Exception)
                    {
                        // Failed to restore session
                    }
                }
            }

            // SessionManagerから全セッションを取得（アーカイブ含む）
            sessions = SessionManager.GetAllSessions().ToList();

            // 保存された展開状態を読み込んで適用
            var expandedStates = await LocalStorageService.LoadSessionExpandedStatesAsync();
            foreach (var session in sessions)
            {
                if (!session.ParentSessionId.HasValue && expandedStates.ContainsKey(session.SessionId))
                {
                    session.IsExpanded = expandedStates[session.SessionId];
                }
            }

            // ConPtyConnectionServiceのイベントハンドラーを設定
            SetupConPtyConnectionEventHandlers();

            // 保存されたアクティブセッションがあれば選択
            var savedActiveId = await LocalStorageService.LoadActiveSessionIdAsync();
            if (savedActiveId != null && sessions.Any(s => s.SessionId == savedActiveId))
            {
                await SelectSession(savedActiveId.Value);
            }

            // UIを更新（セッション一覧を先に表示）
            StateHasChanged();

            // Phase 2: バックグラウンドでGit情報を取得（UIを先に表示した後）
            if (sessionsToPopulateGitInfo.Count > 0)
            {
                _ = Task.Run(async () =>
                {
                    // 並列でGit情報を取得
                    var tasks = sessionsToPopulateGitInfo.Select(async sessionId =>
                    {
                        await SessionManager.PopulateGitInfoForSessionAsync(sessionId);
                    });

                    await Task.WhenAll(tasks);

                    // Git情報取得完了後にUIを更新
                    await InvokeAsync(StateHasChanged);
                });
            }
        }

        // DOSターミナルパネルの参照を保存
        StoreDosTerminalPanelRef();
    }

    [JSInvokable]
    public async Task OnNotificationClick(string sessionId)
    {
        if (Guid.TryParse(sessionId, out var guid))
        {
            await SelectSession(guid);
        }
    }

    private async Task AddSession()
    {
        showCreateDialog = true;
        await Task.CompletedTask; // 必要に応じて非同期処理を追加
    }

    private void ShowSettings()
    {
        showSettingsDialog = true;
    }

    private void HandleSessionSortModeChanged(string sortMode)
    {
        sessionSortMode = sortMode;
        StateHasChanged();
    }

    private async Task SwitchBottomPanelTab(BottomPanelTab tab)
    {
        bottomPanelTab = tab;
        StateHasChanged();

        if (tab == BottomPanelTab.DosTerminal && activeSessionId != null)
        {
            // DOSターミナルタブに切り替え - 常に新しいXTermを作成
            await CleanupSingleDosTerminal();
            // タスクランナーターミナルはクリーンアップしない（保持）
            await InitializeSingleDosTerminal();
        }
        else if (tab == BottomPanelTab.TaskRunner && activeSessionId != null)
        {
            // タスクランナータブに切り替え
            await CleanupSingleDosTerminal();

            // 現在のセッションのpackage.jsonを確認
            var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
            if (currentSession != null)
            {
                hasPackageJson = await PackageJsonService.HasPackageJsonAsync(currentSession.FolderPath);
                // package.jsonの有無に関わらずタスクランナーを表示
                await LoadNpmScripts();

                // 既に初期化済みの場合は再初期化しない
                if (!TaskRunnerInitialized)
                {
                    await InitializeTaskRunnerTerminal();
                }
                else
                {
                    // 既存のターミナルを表示
                    if (taskRunnerTerminal != null)
                    {
                        await JSRuntime.InvokeVoidAsync("terminalFunctions.showTerminal", "task-runner-terminal");
                    }
                }
            }
        }
        else if (tab == BottomPanelTab.TextInput)
        {
            // テキスト入力タブに切り替え - DOSターミナルのみクリーンアップ
            // タスクランナーターミナルは保持（タスク実行ボタンから使う可能性があるため）
            await CleanupSingleDosTerminal();
        }
    }

    private async Task InitializeSingleDosTerminal()
    {
        try
        {
            if (activeSessionId == null) return;

            var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
            if (currentSession == null) return;


            // ConPTYセッションがなければ作成
            if (currentSession.DosTerminalConPtySession == null)
            {
                var conPtyService = new ConPtyService(LoggerFactory.CreateLogger<ConPtyService>());
                var conPtySession = await conPtyService.CreateSessionAsync("cmd.exe", "", currentSession.FolderPath, 120, 30);

                currentSession.DosTerminalConPtySession = conPtySession;
                conPtySession.Start();

                // ハンドラーを作成して登録（後で解除可能にする）
                var sessionId = currentSession.SessionId;
                var dataReceivedHandler = new EventHandler<DataReceivedEventArgs>((sender, args) =>
                    OnDosTerminalDataReceived(sessionId, args.Data));
                var processExitedHandler = new EventHandler((sender, args) =>
                    OnDosTerminalExited(sessionId));

                conPtySession.DataReceived += dataReceivedHandler;
                conPtySession.ProcessExited += processExitedHandler;

                // 辞書に保存（クリーンアップ時に使用）
                _dosTerminalHandlers[sessionId] = (dataReceivedHandler, processExitedHandler);

                // ConPTYの初期化が完了するまで少し待つ
                await Task.Delay(100);
            }

            // DOM要素の存在を確認
            var elementExists = await JSRuntime.InvokeAsync<bool>("eval", @"
                !!document.getElementById('dos-terminal-container')
            ");

            if (!elementExists)
            {
                StateHasChanged();
                await Task.Delay(200); // DOM更新を待つ
            }

            // 新しいXTermを作成
            singleDosTerminal = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "terminalFunctions.createMultiSessionTerminal",
                "dos-terminal-container",
                $"dos-terminal-{activeSessionId}",
                dotNetRef
            );

            currentDosTerminalSessionId = activeSessionId;

            // リサイズは再接続時に自動的に送られるため、ここでは明示的に送らない

            // フォーカスとリサイズ
            await JSRuntime.InvokeVoidAsync("eval", $@"
                (function() {{
                    const termObj = window.multiSessionTerminals && window.multiSessionTerminals['dos-terminal-{activeSessionId}'];
                    if (termObj && termObj.terminal) {{
                        termObj.terminal.focus();
                        if (termObj.fitAddon) {{
                            termObj.fitAddon.fit();
                        }}
                    }}
                }})()
            ");
        }
        catch (Exception ex)
        {
            toast?.ShowError($"DOSターミナルの初期化エラー: {ex.Message}");
        }
    }

    private async Task CleanupSingleDosTerminal()
    {
        try
        {
            if (singleDosTerminal != null)
            {

                // JavaScriptで破棄
                await JSRuntime.InvokeVoidAsync("eval", $@"
                    (function() {{
                        const terminalId = 'dos-terminal-{currentDosTerminalSessionId}';
                        const termObj = window.multiSessionTerminals && window.multiSessionTerminals[terminalId];
                        if (termObj) {{
                            termObj.terminal.dispose();
                            delete window.multiSessionTerminals[terminalId];
                        }}
                    }})()
                ");

                await singleDosTerminal.DisposeAsync();
                singleDosTerminal = null;
                currentDosTerminalSessionId = null;
            }
        }
        catch (Exception)
        {
            // Ignore DOS terminal cleanup errors
        }
    }

    private async void OnDosTerminalDataReceived(Guid sessionId, string data)
    {
        // アクティブなセッションのDOSターミナルデータのみ表示
        if (singleDosTerminal != null && sessionId == currentDosTerminalSessionId)
        {
            await InvokeAsync(async () =>
            {
                await singleDosTerminal.InvokeVoidAsync("write", data);
            });
        }
    }

    private void OnDosTerminalExited(Guid sessionId)
    {
        InvokeAsync(async () =>
        {
            var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
            if (session != null)
            {
                // 現在表示中のDOSターミナルの場合はクリーンアップ
                if (currentDosTerminalSessionId == sessionId)
                {
                    await CleanupSingleDosTerminal();
                }

                // イベントハンドラーを解除してから破棄
                CleanupDosTerminalHandlers(sessionId, session.DosTerminalConPtySession);

                session.DosTerminalConPtySession?.Dispose();
                session.DosTerminalConPtySession = null;

                // 再起動できるように通知
                StateHasChanged();
            }
        });
    }

    /// <summary>
    /// DOSターミナルのイベントハンドラーを解除
    /// </summary>
    private void CleanupDosTerminalHandlers(Guid sessionId, ConPtySession? conPtySession)
    {
        if (_dosTerminalHandlers.TryGetValue(sessionId, out var handlers))
        {
            if (conPtySession != null)
            {
                conPtySession.DataReceived -= handlers.DataReceived;
                conPtySession.ProcessExited -= handlers.ProcessExited;
            }
            _dosTerminalHandlers.Remove(sessionId);
        }
    }

    #region 下部パネルタブ管理

    private async Task InitializeBottomPanelTabs()
    {
        // デフォルトタブを設定
        bottomPanelTabs = new List<BottomPanelTabInfo>
        {
            new() { Id = "default-text", Type = BottomPanelTabType.TextInput, DisplayName = "テキスト入力", IsDefault = true },
            new() { Id = "default-dos", Type = BottomPanelTabType.DosTerminal, DisplayName = "DOSターミナル", IsDefault = true }
        };

        // LocalStorageから追加タブを復元
        try
        {
            var savedTabs = await LocalStorageService.GetAsync<List<BottomPanelTabInfo>>("bottomPanelTabs");
            if (savedTabs != null)
            {
                bottomPanelTabs.AddRange(savedTabs.Where(t => !t.IsDefault));
            }

            var savedActiveId = await LocalStorageService.GetAsync<string>("activeBottomPanelTabId");
            if (!string.IsNullOrEmpty(savedActiveId) && bottomPanelTabs.Any(t => t.Id == savedActiveId))
            {
                activeBottomPanelTabId = savedActiveId;
            }
        }
        catch
        {
            // エラー時はデフォルト値を使用
        }
    }

    private async Task SaveBottomPanelTabs()
    {
        try
        {
            // デフォルト以外のタブのみ保存
            var tabsToSave = bottomPanelTabs.Where(t => !t.IsDefault).ToList();
            await LocalStorageService.SetAsync("bottomPanelTabs", tabsToSave);
            await LocalStorageService.SetAsync("activeBottomPanelTabId", activeBottomPanelTabId);
        }
        catch
        {
            // エラーは無視
        }
    }

    private async Task AddBottomPanelTab(BottomPanelTabType type)
    {
        var count = bottomPanelTabs.Count(t => t.Type == type);
        var displayName = type == BottomPanelTabType.TextInput
            ? $"テキスト入力({count + 1})"
            : $"DOSターミナル({count + 1})";

        var newTab = new BottomPanelTabInfo
        {
            Id = Guid.NewGuid().ToString(),
            Type = type,
            DisplayName = displayName,
            IsDefault = false
        };

        bottomPanelTabs.Add(newTab);
        activeBottomPanelTabId = newTab.Id;

        await SaveBottomPanelTabs();
        StateHasChanged();
    }

    private async Task RemoveBottomPanelTab(string tabId)
    {
        var tab = bottomPanelTabs.FirstOrDefault(t => t.Id == tabId);
        if (tab == null || tab.IsDefault) return;

        // DOSターミナルパネルの破棄
        if (tab.Type == BottomPanelTabType.DosTerminal && dosTerminalPanelRefs.TryGetValue(tabId, out var panel))
        {
            await panel.DisposeAsync();
            dosTerminalPanelRefs.Remove(tabId);
        }

        bottomPanelTabs.Remove(tab);

        // アクティブタブが削除された場合は最初のタブを選択
        if (activeBottomPanelTabId == tabId)
        {
            activeBottomPanelTabId = bottomPanelTabs.FirstOrDefault()?.Id ?? "default-text";
        }

        await SaveBottomPanelTabs();
        StateHasChanged();
    }

    private async Task SelectBottomPanelTab(string tabId)
    {
        activeBottomPanelTabId = tabId;
        await SaveBottomPanelTabs();
    }

    private string GetBottomPanelTabIcon(BottomPanelTabType type)
    {
        return type == BottomPanelTabType.TextInput ? "bi-chat-left-text" : "bi-terminal";
    }

    private string GetTextInputPanelText(string panelId)
    {
        return textInputPanelTexts.TryGetValue(panelId, out var text) ? text : "";
    }

    private void SetTextInputPanelText(string panelId, string text)
    {
        textInputPanelTexts[panelId] = text;
    }

    private async Task HandleTextInputSend(string text)
    {
        if (activeSession == null) return;

        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) return;

        // テキストがある場合は送信
        if (!string.IsNullOrWhiteSpace(text))
        {
            try
            {
                await activeSession.WriteAsync(text);

                // 最終利用時刻を更新（ソート用）
                if (activeSessionId.HasValue)
                {
                    var sessionInfo = SessionManager.GetSessionInfo(activeSessionId.Value);
                    if (sessionInfo != null)
                    {
                        Logger.LogInformation("[LastAccessedAt更新] きっかけ: HandleTextInputSend(テキスト送信), セッション: {SessionName}", sessionInfo.GetDisplayName());
                        sessionInfo.LastAccessedAt = DateTime.Now;
                        StateHasChanged(); // セッションリストのソート順を更新
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }

            // テキスト送信後、Enter送信前に0.2秒待機
            await Task.Delay(200);
        }

        // Enterキーを送信（空の場合でも送信）
        await SendEnterKeyDirect();
    }

    private void StoreDosTerminalPanelRef()
    {
        if (currentDosTerminalPanelRef != null)
        {
            var activeTab = bottomPanelTabs.FirstOrDefault(t => t.Id == activeBottomPanelTabId);
            if (activeTab != null && activeTab.Type == BottomPanelTabType.DosTerminal)
            {
                dosTerminalPanelRefs[activeTab.Id] = currentDosTerminalPanelRef;
            }
        }
    }

    #endregion

    private async Task OnSessionCreate(SessionCreateDialog.SessionCreateResult result)
    {
        showCreateDialog = false;
        isAddingSession = true;

        try
        {
            var sessionInfo = await SessionManager.CreateSessionAsync(
                result.FolderPath, 
                "", // セッション名は空（フォルダ名を使用）
                result.TerminalType, 
                result.Options);

            sessions = SessionManager.GetAllSessions().ToList();

            // ローカルストレージに保存
            await LocalStorageService.SaveSessionsAsync(sessions);

            // 新しいセッションをConPtyConnectionServiceに登録
            if (sessionInfo.ConPtySession != null)
            {
                sessionInfo.LastConnectionTime = DateTime.Now;
                ConPtyConnection.SubscribeToSession(sessionInfo.SessionId, sessionInfo.ConPtySession);
            }

            StateHasChanged();

            await Task.Delay(TerminalConstants.DomUpdateDelay);
            await SelectSession(sessionInfo.SessionId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Session creation failed");
            toast?.ShowError($"セッション作成エラー: {ex.Message}");
        }
        finally
        {
            isAddingSession = false;
        }
    }

    private void OnDialogCancel()
    {
        showCreateDialog = false;
    }


    private async Task SelectSession(Guid sessionId)
    {
        if (activeSessionId == sessionId)
        {
            return;
        }

        // 前のセッションの処理は継続させるため、キャンセルしない

        // 既存のアクティブターミナルを破棄
        if (activeTerminal != null)
        {
            try
            {
                await activeTerminal.DisposeAsync();
            }
            catch (Exception)
            {
                // Ignore terminal disposal errors
            }
            activeTerminal = null;
        }

        // すべてのターミナルを非表示にする（JavaScriptで直接制御）
        await TerminalService.HideAllTerminalsAsync();

        // セッションをアクティブに
        await SessionManager.SetActiveSessionAsync(sessionId);
        activeSessionId = sessionId;


        // 再起動後の新しいセッションを確実に取得
        activeSession = await SessionManager.GetSessionAsync(sessionId);

        // セッションが存在しない場合はエラー
        if (activeSession == null)
        {
            // セッションが見つからない
            activeSessionId = null;
            return;
        }


        // 通知フラグをクリア
        var selectedSession = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (selectedSession != null && selectedSession.HasNotificationPending)
        {
            Logger.LogInformation("[通知マーク OFF] きっかけ: SelectSession(セッション選択), セッション: {SessionName}", selectedSession.GetDisplayName());
            selectedSession.HasNotificationPending = false;
        }

        // アクティブセッション変更を即座にUIに反映
        StateHasChanged();

        // アクティブセッションIDをローカルストレージに保存
        await LocalStorageService.SaveActiveSessionIdAsync(sessionId);

        // ターミナルdivが存在するか確認し、表示する
        var divExists = await TerminalService.CheckElementExistsAsync($"terminal-{sessionId}");
        if (divExists)
        {
            // 新しいターミナルを表示
            await TerminalService.ShowTerminalAsync(sessionId);
        }

        // ターミナルを初期化
        await InitializeTerminal(sessionId);


        // ConPtySessionのリサイズトリックでバッファ内容を再取得
        if (selectedSession?.ConPtySession != null)
        {
            // 過去バッファの誤検出を防ぐため、接続時刻を記録
            selectedSession.LastConnectionTime = DateTime.Now;

            // リサイズ処理全体で不要なデータを破棄
            selectedSession.ConPtySession.SuspendOutput();

            // ターミナルのリサイズを強制的に実行
            if (activeTerminal != null)
            {
                await TerminalService.ResizeTerminalAsync(activeTerminal);
            }

            await Task.Delay(100); // ターミナル初期化完了を待つ

            // 現在のサイズを取得
            var currentCols = selectedSession.ConPtySession.Cols;
            var currentRows = selectedSession.ConPtySession.Rows;

            // リサイズトリック：1行減らして元に戻す
            selectedSession.ConPtySession.Resize(currentCols, currentRows - 1);
            await Task.Delay(50);

            // 2回目のリサイズから送出を再開（これが本来欲しいバッファ内容）
            selectedSession.ConPtySession.ResumeOutput();
            selectedSession.ConPtySession.Resize(currentCols, currentRows);
        }
        else if (activeTerminal != null)
        {
            // ConPtySessionがない場合は通常のリサイズのみ
            await TerminalService.ResizeTerminalAsync(activeTerminal);
        }

        // ConPtySessionをConPtyConnectionServiceに登録
        // RestartSessionAsync後の新しいConPtySessionを確実に取得するため、SessionManagerから最新情報を取得
        var latestSessionInfo = SessionManager.GetSessionInfo(sessionId);
        if (latestSessionInfo?.ConPtySession != null)
        {
            latestSessionInfo.LastConnectionTime = DateTime.Now;
            ConPtyConnection.SubscribeToSession(latestSessionInfo.SessionId, latestSessionInfo.ConPtySession);
        }
        else
        {
            // ConPty session not found - continue without subscription
        }

        // package.jsonの存在をチェック
        if (selectedSession != null)
        {
            hasPackageJson = await PackageJsonService.HasPackageJsonAsync(selectedSession.FolderPath);
            // チェックされたスクリプトを復元
            checkedScripts = new HashSet<string>(selectedSession.CheckedScripts);
            
            // package.jsonが存在する場合はnpm scriptsを読み込み
            if (hasPackageJson)
            {
                await LoadNpmScripts();
            }

            StateHasChanged(); // UIを更新
        }

        // テキストエリアにフォーカス
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.focusTextArea");
        }
        catch (Exception)
        {
            // エラーは無視
        }

        // 現在のタブに応じてターミナルを再作成
        if (bottomPanelTab == BottomPanelTab.DosTerminal && selectedSession != null)
        {
            // 既存のDOSターミナルをクリーンアップして新しく作成
            await CleanupSingleDosTerminal();
            await InitializeSingleDosTerminal();
        }
        else if (bottomPanelTab == BottomPanelTab.TaskRunner && selectedSession != null)
        {
            // npm scriptsを読み込み
            await LoadNpmScripts();
            await InitializeTaskRunnerTerminal();
        }
    }

    private async Task InitializeTerminal(Guid sessionId)
    {
        activeTerminal = await TerminalService.InitializeTerminalAsync(sessionId, DotNetObjectReference.Create<object>(this));
    }

    private async Task ProcessReceivedData(Guid sessionId, string data)
    {
        try
        {
            var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
            if (sessionInfo != null)
            {
                // バッファキャプチャが有効な場合は追記
                sessionInfo.AppendToBuffer(data);

                // Claude Codeの場合、"No conversation found to continue"エラーをチェック
                if (sessionInfo.TerminalType == TerminalType.ClaudeCode && 
                    data.Contains("No conversation found to continue") &&
                    sessionInfo.Options.ContainsKey("continue") &&
                    !sessionInfo.HasContinueErrorOccurred)
                {
                    // Claude Continue Error detected

                    // フラグを設定して重複送信を防ぐ
                    sessionInfo.HasContinueErrorOccurred = true;

                    // セッション再起動のコマンドを送信
                    _ = InvokeAsync(async () =>
                    {
                        await RecreateSessionWithoutContinue(sessionId);
                    });
                    return;
                }

                // アクティブセッションの場合は直接ターミナルに出力
                if (activeSessionId == sessionId && activeTerminal != null)
                {
                    await TerminalService.WriteToTerminalAsync(activeTerminal, data);

                    // 出力解析の実行
                    _ = InvokeAsync(() => 
                    {
                        OutputAnalyzerService.AnalyzeOutput(data, sessionInfo, activeSessionId ?? Guid.Empty,
                            (id, status) => InvokeAsync(() => 
                            {
                                StateHasChanged();
                            }));
                    });
                }
                else
                {
                    // 非アクティブセッションの場合もデータを処理
                    // ただし、出力解析は実行してステータスを更新
                    _ = InvokeAsync(() => 
                    {
                        OutputAnalyzerService.AnalyzeOutput(data, sessionInfo, activeSessionId ?? Guid.Empty,
                            (id, status) => InvokeAsync(() => 
                            {
                                StateHasChanged();
                            }));
                    });
                }
            }
        }
        catch (Exception)
        {
            // ProcessReceivedData error
        }
    }



    private async Task HandleSessionExpandedChanged((Guid sessionId, bool isExpanded) args)
    {
        // 展開状態をLocalStorageに保存
        await SaveExpandedStatesToLocalStorage();
    }

    private async Task SaveExpandedStatesToLocalStorage()
    {
        var expandedStates = sessions
            .Where(s => !s.ParentSessionId.HasValue) // 親セッションのみ
            .ToDictionary(s => s.SessionId, s => s.IsExpanded);

        await LocalStorageService.SaveSessionExpandedStatesAsync(expandedStates);
    }


    private async Task UpdateSessionMemo(Guid sessionId, string memo)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            session.Memo = memo;
            // ローカルストレージを更新
            await LocalStorageService.SaveSessionsAsync(sessions);
        }
    }

    private async Task RemoveSession(Guid sessionId)
    {
        // 削除確認
        var sessionToRemove = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionToRemove != null)
        {
            var sessionName = sessionToRemove.GetDisplayName();
            bool confirmed;
            try
            {
                confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"セッション「{sessionName}」を削除しますか？");
            }
            catch (JSDisconnectedException)
            {
                return;
            }
            catch (Exception)
            {
                return;
            }
            if (!confirmed)
            {
                return;
            }
            
            // ConPtySessionのクリーンアップ
            // 現在表示中のDOSターミナルを使用している場合はクリーンアップ
            if (currentDosTerminalSessionId == sessionId)
            {
                await CleanupSingleDosTerminal();
            }

            // DOS ConPTYセッションのクリーンアップ（ハンドラー解除後に破棄）
            CleanupDosTerminalHandlers(sessionId, sessionToRemove.DosTerminalConPtySession);
            sessionToRemove.DosTerminalConPtySession?.Dispose();
            sessionToRemove.DosTerminalConPtySession = null;

            // ConPtySessionのクリーンアップ
            if (sessionToRemove.ConPtySession != null)
            {
                sessionToRemove.ConPtySession.Dispose();
            }
        }

        // セッションのタイマーを停止
        OutputAnalyzerService.StopSessionTimer(sessionId);


        // アクティブセッションの場合の追加処理
        if (sessionId == activeSessionId)
        {

            if (activeTerminal != null)
            {
                await activeTerminal.DisposeAsync();
                activeTerminal = null;
            }
        }

        // ターミナルのクリーンアップはdestroyTerminalで処理される

        await SessionManager.RemoveSessionAsync(sessionId);
        sessions = SessionManager.GetAllSessions().ToList();

        // ローカルストレージを更新
        await LocalStorageService.SaveSessionsAsync(sessions);

        if (activeSessionId == sessionId)
        {
            activeSessionId = null;
            activeSession = null;

            // セッション削除を即座にUIに反映
            StateHasChanged();

            await LocalStorageService.SaveActiveSessionIdAsync(null);

            // 他のセッションがあれば最初のものを選択
            if (sessions.Any())
            {
                await SelectSession(sessions.First().SessionId);
            }
        }
        else
        {
            // 削除されたセッションがアクティブでない場合もUIを更新
            StateHasChanged();
        }
    }

    private async Task ArchiveSession(Guid sessionId)
    {
        var sessionToArchive = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionToArchive == null) return;

        var sessionName = sessionToArchive.GetDisplayName();
        bool confirmed;
        try
        {
            confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"セッション「{sessionName}」をアーカイブしますか？");
        }
        catch (JSDisconnectedException)
        {
            return;
        }
        catch (Exception)
        {
            return;
        }
        if (!confirmed) return;

        // DOSターミナルのクリーンアップ
        if (currentDosTerminalSessionId == sessionId)
        {
            await CleanupSingleDosTerminal();
        }

        // セッションのタイマーを停止
        OutputAnalyzerService.StopSessionTimer(sessionId);

        // アクティブセッションの場合の追加処理
        if (sessionId == activeSessionId)
        {
            if (activeTerminal != null)
            {
                await activeTerminal.DisposeAsync();
                activeTerminal = null;
            }
        }

        // SessionManagerでアーカイブ処理（ConPtySessionの破棄含む）
        SessionManager.ArchiveSession(sessionId);

        // ローカルストレージを更新（再起動時の復元用）
        sessions = SessionManager.GetAllSessions().ToList();
        await LocalStorageService.SaveSessionsAsync(sessions);

        if (activeSessionId == sessionId)
        {
            activeSessionId = null;
            activeSession = null;
            await LocalStorageService.SaveActiveSessionIdAsync(null);

            // アーカイブされていない他のセッションがあれば最初のものを選択
            var activeSessionsList = SessionManager.GetActiveSessions().ToList();
            if (activeSessionsList.Any())
            {
                await SelectSession(activeSessionsList.First().SessionId);
            }
        }

        StateHasChanged();
    }

    private async Task RestoreArchivedSession(Guid sessionId)
    {
        try
        {
            // SessionManagerでアーカイブから復元
            var restoredSession = await SessionManager.RestoreArchivedSessionAsync(sessionId);
            if (restoredSession == null)
            {
                Logger.LogWarning("アーカイブセッションの復元に失敗しました: {SessionId}", sessionId);
                return;
            }

            // SessionManagerから最新のセッションリストを取得
            sessions = SessionManager.GetAllSessions().ToList();

            // ローカルストレージを更新
            await LocalStorageService.SaveSessionsAsync(sessions);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "アーカイブセッションの復元に失敗しました: {SessionId}", sessionId);
        }
    }

    private async Task DeleteArchivedSession(Guid sessionId)
    {
        // SessionManagerから完全削除
        SessionManager.DeleteSession(sessionId);

        // SessionManagerから最新のセッションリストを取得
        sessions = SessionManager.GetAllSessions().ToList();

        await LocalStorageService.SaveSessionsAsync(sessions);
        StateHasChanged();
    }

    private async Task DeleteAllArchivedSessions()
    {
        // アーカイブされた全セッションを削除
        var archivedSessions = SessionManager.GetAllSessions().Where(s => s.IsArchived).ToList();
        foreach (var session in archivedSessions)
        {
            SessionManager.DeleteSession(session.SessionId);
        }

        // SessionManagerから最新のセッションリストを取得
        sessions = SessionManager.GetAllSessions().ToList();

        await LocalStorageService.SaveSessionsAsync(sessions);
        StateHasChanged();
    }

    private List<SessionInfo> GetArchivedSessions()
    {
        return SessionManager.GetAllSessions().Where(s => s.IsArchived).ToList();
    }

    [JSInvokable]
    public async Task SendInput(string sessionId, string data)
    {

        try
        {
            // タスクランナーターミナルからの入力を処理
            if (sessionId == "task-runner-terminal")
            {
                if (TaskManagerService.ActiveSession != null)
                {
                    await TaskManagerService.SendInputAsync(TaskManagerService.ActiveSession.Id, data ?? string.Empty);
                }
                else
                {
                }
            }
            // DOSターミナルからの入力を処理（singleDosTerminal用）
            else if (sessionId.StartsWith("dos-terminal-"))
            {
                var guidStr = sessionId.Replace("dos-terminal-", "");
                if (Guid.TryParse(guidStr, out var guid))
                {
                    var session = sessions.FirstOrDefault(s => s.SessionId == guid);
                    if (session?.DosTerminalConPtySession != null)
                    {
                        await session.DosTerminalConPtySession.WriteAsync(data ?? string.Empty);
                    }
                }
            }
            // DosTerminalPanelからの入力を処理
            else if (sessionId.StartsWith("dos-term-"))
            {
                var panelId = sessionId.Replace("dos-term-", "");
                if (dosTerminalPanelRefs.TryGetValue(panelId, out var dosPanel))
                {
                    await dosPanel.WriteInput(data ?? string.Empty);
                }
            }
            else
            {
                // 通常のセッションからの入力を処理
                var guid = Guid.Parse(sessionId);
                if (activeSession != null && guid == activeSessionId)
                {
                    await activeSession.WriteAsync(data ?? string.Empty);
                }
            }
        }
        catch (Exception)
        {
            throw;
        }
    }

    [JSInvokable]
    public void OnTerminalSizeChanged(string sessionId, int cols, int rows)
    {
        // DOSターミナルのサイズ変更を処理（singleDosTerminal用）
        if (sessionId.StartsWith("dos-terminal-"))
        {
            var guidStr = sessionId.Replace("dos-terminal-", "");
            if (Guid.TryParse(guidStr, out var guid))
            {
                var session = sessions.FirstOrDefault(s => s.SessionId == guid);
                if (session?.DosTerminalConPtySession != null)
                {
                    session.DosTerminalConPtySession.Resize(cols, rows);
                }
            }
        }
        // DosTerminalPanelのサイズ変更を処理
        else if (sessionId.StartsWith("dos-term-"))
        {
            var panelId = sessionId.Replace("dos-term-", "");
            if (dosTerminalPanelRefs.TryGetValue(panelId, out var dosPanel))
            {
                dosPanel.SendResize(cols, rows);
            }
        }
        // タスクランナーターミナルのサイズ変更を処理
        else if (sessionId == "task-runner-terminal")
        {
            
            // 現在接続中のタスクセッションがあればリサイズ
            if (!string.IsNullOrEmpty(selectedScript))
            {
                var taskSession = GetTaskSessionByScriptName(selectedScript);
                if (taskSession?.IsTerminalConnected == true && TaskManagerService != null)
                {
                    // TaskManagerServiceを通じてConPtySessionをリサイズ
                    TaskManagerService.ResizeSession(taskSession.Id, cols, rows);
                }
            }
        }
        else
        {
            // 通常のセッションのサイズ変更を処理
            if (!Guid.TryParse(sessionId, out var guid))
            {
                // GUIDではない値（タスクランナーなど）は無視
                return;
            }
            if (guid == activeSessionId && activeSession != null)
            {
                // ConPtyにリサイズを通知
                activeSession.Resize(cols, rows);

                // ConPtySessionもリサイズを通知
                var selectedSession = sessions.FirstOrDefault(s => s.SessionId == guid);
                if (selectedSession?.ConPtySession != null)
                {
                    selectedSession.ConPtySession.Resize(cols, rows);
                }

                // リサイズ時のスナップショット再表示は削除
                // ConPTYは自身でリフロー処理を行い、アプリケーションが再描画する
                // 手動でクリア＆再描画すると、ConPTYの再描画と競合する可能性がある
            }
        }
    }

    private async Task DestroyTerminal(Guid sessionId, bool showAlert = true)
    {
        try
        {
            // JavaScript側のターミナルを破棄
            await TerminalService.DestroyTerminalAsync(sessionId, showAlert);

            // C#側のターミナル参照を削除（アクティブセッションの場合のみ）
            if (activeSessionId == sessionId && activeTerminal != null)
            {
                await activeTerminal.DisposeAsync();
                activeTerminal = null;
            }

            if (showAlert)
            {
                toast?.ShowSuccess("ターミナルを破棄しました");
            }
        }
        catch (Exception ex)
        {
            if (showAlert)
            {
                toast?.ShowError($"ターミナル破棄エラー: {ex.Message}");
            }
        }
    }

    private async Task RecreateTerminal(Guid sessionId)
    {
        try
        {
            // セッションがアクティブな場合のみ再作成
            if (activeSessionId == sessionId)
            {
                // 既存のターミナルを破棄（アラートなし）
                await DestroyTerminal(sessionId, false);

                // 新しいターミナルを初期化
                await InitializeTerminal(sessionId);

                // ターミナル再作成処理
                var selectedSessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
                await TerminalService.RecreateTerminalAsync(sessionId, selectedSessionInfo!, activeSession);

                // ConPtyConnectionServiceに再登録
                if (selectedSessionInfo?.ConPtySession != null)
                {
                    selectedSessionInfo.LastConnectionTime = DateTime.Now;
                    ConPtyConnection.SubscribeToSession(selectedSessionInfo.SessionId, selectedSessionInfo.ConPtySession);
                }

                toast?.ShowSuccess("ターミナルを再作成しました");
            }
            else
            {
                toast?.ShowWarning("このセッションを選択してからターミナルを再作成してください");
            }
        }
        catch (Exception ex)
        {
            toast?.ShowError($"ターミナル再作成エラー: {ex.Message}");
        }
    }





    private async Task SendInput()
    {

        if (activeSession == null)
        {
            return;
        }

        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null)
        {
            return;
        }

        // テキストがある場合は送信
        if (!string.IsNullOrWhiteSpace(inputText))
        {

            // テキスト履歴に追加
            InputHistoryService.AddToHistory(inputText);

            try
            {
                await activeSession.WriteAsync(inputText);

                // 最終利用時刻を更新（ソート用）
                if (activeSessionId.HasValue)
                {
                    var sessionInfo = SessionManager.GetSessionInfo(activeSessionId.Value);
                    if (sessionInfo != null)
                    {
                        Logger.LogInformation("[LastAccessedAt更新] きっかけ: SendInput(入力送信), セッション: {SessionName}", sessionInfo.GetDisplayName());
                        sessionInfo.LastAccessedAt = DateTime.Now;
                        StateHasChanged(); // セッションリストのソート順を更新
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }

            // テキスト送信後、Enter送信前に0.2秒待機
            await Task.Delay(200);
        }

        // Enterキーを送信（空の場合でも送信）
        await SendEnterKeyDirect();

        // 入力フィールドをクリア
        inputText = "";
    }

    private async Task OnTextAreaKeyDown(KeyboardEventArgs e)
    {
        // Enter で送信（Shiftキーが押されていない場合）
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendInput();
        }
        // Ctrl+C: 強制中断
        else if (e.Key == "c" && e.CtrlKey && !e.AltKey && !e.ShiftKey)
        {
            await SendCtrlC();
        }
        // Escape: 中断
        else if (e.Key == "Escape")
        {
            await SendEscape();
        }
        // モード切替（ClaudeCodeモードのみ）- Alt+M または Shift+Tab（設定による）
        else if ((claudeModeSwitchKey == "altM" && e.Key == "m" && e.AltKey && !e.CtrlKey && !e.ShiftKey) ||
                 (claudeModeSwitchKey == "shiftTab" && e.Key == "Tab" && e.ShiftKey && !e.CtrlKey && !e.AltKey))
        {
            var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
            if (currentSession?.TerminalType == TerminalType.ClaudeCode)
            {
                await SendModeSwitch();
            }
        }
        // 履歴機能: 上矢印で前の履歴、下矢印で次の履歴
        else if (e.Key == "ArrowUp" && e.CtrlKey)
        {
            var historyText = InputHistoryService.NavigateHistory(-1);
            if (historyText != null)
                inputText = historyText;
        }
        else if (e.Key == "ArrowDown" && e.CtrlKey)
        {
            var historyText = InputHistoryService.NavigateHistory(1);
            if (historyText != null)
                inputText = historyText;
        }
        // Shift+Enter は通常の改行動作（何もしない）
    }

    private string GetPlaceholderText(TerminalType terminalType)
    {
        return terminalType switch
        {
            TerminalType.ClaudeCode => "Claude Codeへのメッセージを入力...",
            TerminalType.GeminiCLI => "Gemini CLIへのメッセージを入力...",
            _ => "コマンドを入力..."
        };
    }

    private string claudeModeSwitchKey = "altM";

    private async Task SendCtrlC()
    {
        if (activeSession == null)
            return;

        // Ctrl+Cを送信（\x03 はCtrl+Cの制御文字）
        await activeSession.WriteAsync("\x03");
    }

    private async Task SendEscape()
    {
        if (activeSession == null)
            return;

        // Escキーを送信（\x1B はESCのエスケープシーケンス）
        await activeSession.WriteAsync("\x1B");
    }

    private async Task SendModeSwitch()
    {
        if (activeSession == null)
            return;

        // Alt+M を送信（\x1B はESC、m はM）
        await activeSession.WriteAsync("\x1Bm");
    }


    private void ShowWorktreeDialog(Guid sessionId)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            // Git管理されていない場合でも、サブセッションダイアログは表示する
            // （同じフォルダで開くオプションは利用可能）
            subSessionParentSessionId = sessionId;
            subSessionParentSessionName = session.GetDisplayName();
            subSessionParentSessionPath = session.FolderPath;
            subSessionParentSessionIsGitRepository = session.IsGitRepository;
            showSubSessionDialog = true;
        }
    }

    private async Task OnSubSessionOperation(SubSessionDialog.SubSessionResult result)
    {
        if (!subSessionParentSessionId.HasValue)
        {
            showSubSessionDialog = false;
            return;
        }

        try
        {
            SessionInfo? newSession = null;

            switch (result.OperationType)
            {
                case SubSessionDialog.SubSessionType.CreateNew:
                    // Worktree作成（新規・既存ブランチ共通）
                    newSession = await SessionManager.CreateWorktreeSessionAsync(
                        subSessionParentSessionId.Value, result.BranchName, result.TerminalType, result.Options);
                    break;

                case SubSessionDialog.SubSessionType.AddExisting:
                    // 既存Worktree追加
                    if (!string.IsNullOrEmpty(result.WorktreePath))
                    {
                        newSession = await AddExistingWorktreeSession(subSessionParentSessionId.Value, result.WorktreePath, result.BranchName, result.TerminalType, result.Options);
                    }
                    break;

                case SubSessionDialog.SubSessionType.SamePath:
                    // 同じフォルダでセッション作成
                    if (!string.IsNullOrEmpty(subSessionParentSessionPath))
                    {
                        newSession = await SessionManager.CreateSamePathSessionAsync(
                            subSessionParentSessionId.Value, subSessionParentSessionPath, result.TerminalType, result.Options);
                    }
                    break;

                case SubSessionDialog.SubSessionType.NewFolder:
                    // 新しいフォルダでセッション作成
                    if (!string.IsNullOrEmpty(result.WorktreePath))
                    {
                        newSession = await CreateNewFolderSession(
                            subSessionParentSessionId.Value, result.WorktreePath, result.TerminalType, result.Options);
                    }
                    break;
            }

            if (newSession != null)
            {
                // セッション一覧を更新
                sessions = SessionManager.GetAllSessions().ToList();

                // ローカルストレージに保存
                await LocalStorageService.SaveSessionsAsync(sessions);

                // 新しいセッションを選択
                await SelectSession(newSession.SessionId);

                string successMessage = result.OperationType switch
                {
                    SubSessionDialog.SubSessionType.CreateNew => 
                        $"Worktree '{result.BranchName}' を作成しました",
                    SubSessionDialog.SubSessionType.AddExisting => 
                        $"既存のWorktree '{result.BranchName}' を追加しました",
                    SubSessionDialog.SubSessionType.SamePath => 
                        $"新しい{GetSessionTypeName(result.TerminalType)}セッションを作成しました",
                    SubSessionDialog.SubSessionType.NewFolder => 
                        $"新しいフォルダ '{result.WorktreePath}' でセッションを作成しました",
                    _ => "セッションを作成しました"
                };

                toast?.ShowSuccess(successMessage);
            }
            else
            {
                toast?.ShowError("セッション作成に失敗しました");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Sub-session creation failed");
            toast?.ShowError($"セッション作成エラー: {ex.Message}");
        }
        finally
        {
            showSubSessionDialog = false;
            subSessionParentSessionId = null;
            subSessionParentSessionName = null;
            subSessionParentSessionPath = null;
            subSessionParentSessionIsGitRepository = true;
        }
    }

    private string GetSessionTypeName(TerminalType terminalType)
    {
        return terminalType switch
        {
            TerminalType.Terminal => "ターミナル",
            TerminalType.ClaudeCode => "Claude Code",
            TerminalType.GeminiCLI => "Gemini CLI",
            _ => "セッション"
        };
    }

    private async Task<SessionInfo?> AddExistingWorktreeSession(Guid parentSessionId, string worktreePath, string branchName, TerminalType terminalType, Dictionary<string, string> options)
    {
        // 親セッション情報を取得
        var parentSession = SessionManager.GetSessionInfo(parentSessionId);
        if (parentSession == null)
        {
            // Parent session not found
            return null;
        }

        // 既存のWorktreeをセッションとして追加（統一された表示名を使用）
        var sessionInfo = await SessionManager.CreateSessionAsync(
            worktreePath,
            $"{parentSession.DisplayName} ({branchName})",
            terminalType,
            options
        );

        // 親子関係を設定
        if (sessionInfo != null)
        {
            sessionInfo.ParentSessionId = parentSessionId;
            await SessionManager.SaveSessionInfoAsync(sessionInfo);
        }

        return sessionInfo;
    }

    private async Task<SessionInfo?> CreateNewFolderSession(Guid parentSessionId, string folderPath, TerminalType terminalType, Dictionary<string, string> options)
    {
        try
        {
            // 親セッション情報を取得
            var parentSession = SessionManager.GetSessionInfo(parentSessionId);
            if (parentSession == null)
            {
                // Parent session not found
                return null;
            }

            // フォルダが存在しない場合は作成
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
            }

            // 新しいフォルダでセッション作成（統一された表示名を使用）
            var sessionInfo = await SessionManager.CreateSessionAsync(
                folderPath,
                $"{parentSession.DisplayName} ({Path.GetFileName(folderPath)})",
                terminalType,
                options
            );

            // 親子関係を設定
            if (sessionInfo != null)
            {
                sessionInfo.ParentSessionId = parentSessionId;
                await SessionManager.SaveSessionInfoAsync(sessionInfo);
            }

            return sessionInfo;
        }
        catch (Exception)
        {
            // CreateNewFolderSession error
            return null;
        }
    }


    private async Task SendEnterKeyDirect()
    {

        if (activeSession == null)
        {
            return;
        }

        try
        {
            // 様々なEnterキーのパターンを試す
            // Windows環境では通常 \r\n だが、ターミナルによって異なる場合がある
            await activeSession.WriteAsync("\r");
        }
        catch (Exception)
        {
            throw;
        }
    }


    // テキスト履歴関連メソッド

    private async Task OnSessionTimeout(Guid sessionId)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            // すでにステータスがクリアされている場合はスキップ（Hook通知で先にクリアされた場合）
            if (session.ProcessingStatus == null)
            {
                Logger.LogDebug("OnSessionTimeout: ステータスが既にクリア済みのためスキップ: {SessionId}", sessionId);
                return;
            }

            var lastUpdateTime = session.LastProcessingUpdateTime;
            if (!lastUpdateTime.HasValue)
            {
                return;
            }

            // ユーザー入力待ち状態の場合はタイムアウトしない
            if (session.IsWaitingForUserInput)
            {
                // タイマーを再設定
                OutputAnalyzerService.ResetSessionTimer(sessionId);
                return;
            }

            var elapsedTime = (DateTime.Now - lastUpdateTime.Value).TotalSeconds;

            if (elapsedTime >= 5)
            {
                // 5秒間更新がないため処理終了と判定
                // ProcessingStartTimeから実際の経過時間を計算
                int actualElapsedSeconds = 0;
                if (session.ProcessingStartTime.HasValue)
                {
                    actualElapsedSeconds = (int)(DateTime.Now - session.ProcessingStartTime.Value).TotalSeconds;
                }

                // ステータスをクリア
                Logger.LogInformation(
                    "[ステータスクリア] きっかけ: OnSessionTimeout(タイムアウト完了), セッション: {SessionName}, 旧ステータス: {OldStatus}",
                    session.GetDisplayName(),
                    session.ProcessingStatus ?? "(なし)");
                session.ProcessingStatus = null;
                session.ProcessingStartTime = null;
                session.ProcessingElapsedSeconds = null;
                session.LastProcessingUpdateTime = null;
                session.IsWaitingForUserInput = false;

                if (activeSessionId != sessionId)
                {
                    Logger.LogInformation("[通知マーク ON] きっかけ: OnSessionTimeout(タイムアウト完了), セッション: {SessionName}", session.GetDisplayName());
                    session.HasNotificationPending = true;
                }

                // 処理完了の通知（アクティブセッションでも通知する）
                await NotificationService.NotifyProcessingCompleteAsync(session, actualElapsedSeconds);

                // タイマーを停止
                OutputAnalyzerService.StopSessionTimer(sessionId);

                // Gitステータスを更新
                await RefreshGitStatus(sessionId);

                // UIを更新
                StateHasChanged();
            }
            else
            {
                // まだタイムアウトしていないので、タイマーを再設定
                OutputAnalyzerService.ResetSessionTimer(sessionId);
            }
        }
    }

    /// <summary>
    /// SessionManagerからセッション変更通知を受け取ったときの処理
    /// </summary>
    private void OnSessionsChanged()
    {
        // SessionManagerから最新のセッションリストを取得
        sessions = SessionManager.GetAllSessions().ToList();
        StateHasChanged();
    }

    private async Task OnHookNotification(HookNotification notification)
    {
        var eventType = notification.GetEventType();
        if (eventType == null) return;

        var session = sessions.FirstOrDefault(s => s.SessionId == notification.SessionId);
        if (session == null) return;

        Logger.LogInformation(
            "[OnHookNotification] イベント: {EventType}, セッション: {SessionName}, 現在のステータス: {Status}",
            eventType,
            session.GetDisplayName(),
            session.ProcessingStatus ?? "(なし)");

        switch (eventType)
        {
            case HookEventType.Stop:
                // ステータスをクリア（Root.razorのsessionsリスト内のオブジェクトをクリア）
                Logger.LogInformation(
                    "[ステータスクリア] きっかけ: OnHookNotification(Stop), セッション: {SessionName}, 旧ステータス: {OldStatus}",
                    session.GetDisplayName(),
                    session.ProcessingStatus ?? "(なし)");
                session.ProcessingStatus = null;
                session.ProcessingStartTime = null;
                session.ProcessingElapsedSeconds = null;
                session.LastProcessingUpdateTime = null;
                session.IsWaitingForUserInput = false;

                // 非アクティブセッションの場合は通知マークを表示
                if (activeSessionId != notification.SessionId)
                {
                    Logger.LogInformation("[通知マーク ON] きっかけ: OnHookNotification(Hook通知), セッション: {SessionName}", session.GetDisplayName());
                    session.HasNotificationPending = true;
                }

                // タイマーを停止
                OutputAnalyzerService.StopSessionTimer(notification.SessionId);

                // Gitステータスを更新
                await RefreshGitStatus(notification.SessionId);

                // UIを更新
                StateHasChanged();
                break;

            case HookEventType.UserPromptSubmit:
                // 処理開始を記録（既にHookNotificationServiceで設定されているが念のため）
                session.ProcessingStartTime = DateTime.Now;
                session.ProcessingStatus = "処理中";
                session.LastProcessingUpdateTime = DateTime.Now;

                // タイマーを開始
                OutputAnalyzerService.ResetSessionTimer(notification.SessionId);

                // UIを更新
                StateHasChanged();
                break;
        }
    }

    private void ShowSessionSettingsDialog(Guid sessionId)
    {
        settingsSessionId = sessionId;
        showSessionSettingsDialog = true;
    }

    private async Task OnSessionSettingsSaved()
    {
        showSessionSettingsDialog = false;
        // セッション一覧を更新
        sessions = SessionManager.GetAllSessions().ToList();
        await LocalStorageService.SaveSessionsAsync(sessions);

        // セッションが再起動された場合、ターミナルコンポーネントも再読み込み
        if (settingsSessionId.HasValue && settingsSessionId.Value == activeSessionId)
        {
            var sessionId = settingsSessionId.Value;

            // セッション設定による再起動時も既存の購読を解除
            ConPtyConnection.UnsubscribeFromSession(sessionId);

            // 一旦nullにして再選択することで、ターミナルコンポーネントを再作成
            activeSessionId = null;
            activeSession = null;
            StateHasChanged();
            await Task.Delay(100); // UIの更新を待つ
            await SelectSession(sessionId);
        }
        else
        {
            StateHasChanged();
        }

        toast?.ShowSuccess("セッション設定を保存しました");
    }

    private async Task RefreshGitStatus(Guid sessionId)
    {
        var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionInfo != null && sessionInfo.IsGitRepository)
        {
            // Gitステータスを更新
            var gitInfo = await GitService.GetGitInfoAsync(sessionInfo.FolderPath);
            if (gitInfo != null)
            {
                sessionInfo.GitBranch = gitInfo.CurrentBranch;
                sessionInfo.HasUncommittedChanges = gitInfo.HasUncommittedChanges;
                sessionInfo.IsWorktree = gitInfo.IsWorktree;

                await LocalStorageService.SaveSessionsAsync(sessions);
                StateHasChanged();
            }
        }
    }

    private async Task RecreateSessionWithoutContinue(Guid sessionId)
    {
        var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionInfo == null)
        {
            // Session info not found
            return;
        }

        try
        {
            // Recreating session without --continue

            // セッション再作成前に既存の購読を解除
            ConPtyConnection.UnsubscribeFromSession(sessionId);

            // セッションを再作成（HasContinueErrorOccurredフラグにより--continueは自動的に除外される）
            var newSession = await SessionManager.RecreateSessionAsync(sessionId, removeContinueOption: true);
            if (newSession != null)
           {
                // 新しいセッションを購読
                var targetSession = sessions.FirstOrDefault(s => s.SessionId == sessionId);
                if (targetSession != null)
                {
                    targetSession.LastConnectionTime = DateTime.Now;
                }
                ConPtyConnection.SubscribeToSession(sessionId, newSession);
                                // セッションを起動
                newSession.Start();
                newSession.Resize(
                    Configuration.GetValue<int>("SessionSettings:DefaultCols", TerminalConstants.DefaultCols),
                    Configuration.GetValue<int>("SessionSettings:DefaultRows", TerminalConstants.DefaultRows)
                );
                
                // セッション一覧を更新（最新のConPtySession参照を含む）
                sessions = SessionManager.GetAllSessions().ToList();
                
                // ローカルストレージに保存
                await LocalStorageService.SaveSessionsAsync(sessions);
                
                // 強制的にセッションを再初期化するため、一旦nullにする
                activeSessionId = null;
                activeSession = null;
                StateHasChanged();
                await Task.Delay(100); // UIの更新を待つ
                
                // 再作成後のセッションを選択
                await SelectSession(sessionId);
                
                toast?.ShowInfo("--continueオプションなしでセッションを再作成しました");
            }
            else
            {
                // Session recreation failed
                toast?.ShowError("セッション再作成に失敗しました");
            }
        }
        catch (Exception ex)
        {
            // RecreateSessionWithoutContinue error
            Logger.LogError(ex, "Session recreation failed: SessionId={SessionId}", sessionId);
            toast?.ShowError($"セッション再作成エラー: {ex.Message}");
        }
    }
    
    // イベントハンドラーを保持するフィールド
    private EventHandler<ConPtyDataReceivedEventArgs>? _dataReceivedHandler;
    private EventHandler<ConPtyProcessExitedEventArgs>? _processExitedHandler;
    
    private void SetupConPtyConnectionEventHandlers()
    {
        // 既存のハンドラーがあれば削除
        if (_dataReceivedHandler != null)
        {
            ConPtyConnection.DataReceived -= _dataReceivedHandler;
        }
        if (_processExitedHandler != null)
        {
            ConPtyConnection.ProcessExited -= _processExitedHandler;
        }
        
        // 新しいハンドラーを作成
        _dataReceivedHandler = async (sender, args) =>
        {
            try
            {
                await ProcessReceivedData(args.SessionId, args.Data);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "DataReceived processing failed");
            }
        };
        
        _processExitedHandler = (sender, args) =>
        {
            Logger.LogDebug("ConPty process exited: SessionId={SessionId}", args.SessionId);
        };

        // ConPtyConnectionServiceのイベントハンドラーを設定
        ConPtyConnection.DataReceived += _dataReceivedHandler;
        ConPtyConnection.ProcessExited += _processExitedHandler;
        
    }
    
    // タスクランナー関連メソッド
    private async Task LoadNpmScripts()
    {
        if (activeSessionId == null) return;
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) return;
        
        
        // TaskManagerServiceの作業ディレクトリを設定
        TaskManagerService.WorkingDirectory = currentSession.FolderPath ?? Environment.CurrentDirectory;
        
        // スクリプトをロード
        await TaskManagerService.LoadScriptsAsync();
        npmScripts = TaskManagerService.GetAvailableScripts();
        
        
        selectedScript = null;
        StateHasChanged();
    }
    
    private async void SelectScript(string scriptName)
    {
        
        // 同じスクリプトが選択された場合は何もしない
        if (selectedScript == scriptName)
        {
            return;
        }
        
        selectedScript = scriptName;
        
        // TaskManagerServiceのアクティブセッションを設定
        var taskSession = GetTaskSessionByScriptName(scriptName);
        if (taskSession != null)
        {
            TaskManagerService.SetActiveSession(taskSession.Id);
            
            // タスクが実行中で未接続の場合は自動的に接続
            if (taskSession.Status == TaskStatus.Running && !taskSession.IsTerminalConnected)
            {
                await ConnectTerminal(scriptName);
            }
        }
        
        // タスクランナータブが表示されている場合のみXTermを再作成
        if (bottomPanelTab == BottomPanelTab.TaskRunner && TaskRunnerInitialized)
        {
            await RecreateTaskRunnerTerminalForSelectedScript();
        }
    }
    
    // デバッグ用メソッド
    
    
    
    
    private async Task RecreateTaskRunnerTerminalForSelectedScript()
    {
        if (string.IsNullOrEmpty(selectedScript))
        {
            return;
        }
        
        
        try
        {
            
            // 既存のXTermを破棄
            if (taskRunnerTerminal != null)
            {
                await JSRuntime.InvokeVoidAsync("eval", @"
                    (function() {
                        const terminalId = 'task-runner-terminal';
                        const termObj = window.multiSessionTerminals && window.multiSessionTerminals[terminalId];
                        if (termObj) {
                            termObj.terminal.dispose();
                            delete window.multiSessionTerminals[terminalId];
                        }
                    })()
                ");
                
                await taskRunnerTerminal.DisposeAsync();
                taskRunnerTerminal = null;
                TaskRunnerInitialized = false;
            }
            
            // 少し待つ
            await Task.Delay(100);
            
            // 新しいXTermを作成
            await InitializeTaskRunnerTerminal();
            
            // 選択したタスクのセッションがあれば接続
            var taskSession = GetTaskSessionByScriptName(selectedScript);
            if (taskSession != null)
            {
                
                // TaskManagerServiceのアクティブセッションを設定
                TaskManagerService.SetActiveSession(taskSession.Id);
                
                // 既存の出力バッファの内容を表示
                if (taskRunnerTerminal != null)
                {
                    await taskRunnerTerminal.InvokeVoidAsync("write", $"\x1b[94m=== タスク '{selectedScript}' のセッションに切り替えました ===\x1b[0m\r\n");
                    
                    // ステータス表示
                    if (taskSession.Status == TaskStatus.Running)
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", "\x1b[92m[実行中]\x1b[0m\r\n");
                    }
                    else if (taskSession.Status == TaskStatus.Completed)
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", $"\x1b[92m[完了] {taskSession.Duration?.TotalSeconds:F1}秒\x1b[0m\r\n");
                    }
                    else if (taskSession.Status == TaskStatus.Failed)
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", $"\x1b[91m[失敗] 終了コード: {taskSession.ExitCode}\x1b[0m\r\n");
                    }
                    else if (taskSession.Status == TaskStatus.Stopped)
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", "\x1b[93m[停止]\x1b[0m\r\n");
                    }
                    else
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", "\x1b[90m[待機中]\x1b[0m\r\n");
                    }
                    
                    // 出力バッファの内容を表示（コピーを作成してからイテレーション）
                    if (taskSession.OutputBuffer.Count > 0)
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", "\r\n--- 出力履歴 ---\r\n");
                        var outputLines = taskSession.OutputBuffer.ToList();
                        foreach (var line in outputLines)
                        {
                            await taskRunnerTerminal.InvokeVoidAsync("write", line);
                        }
                    }
                }
            }
            else
            {
                
                if (taskRunnerTerminal != null)
                {
                    await taskRunnerTerminal.InvokeVoidAsync("write", $"\x1b[93m=== タスク '{selectedScript}' は未実行です ===\x1b[0m\r\n");
                }
            }
        }
        catch (Exception)
        {
            // Ignore task runner terminal recreation errors
        }
    }
    
    private void ToggleScriptCheck(string scriptName)
    {
        if (activeSessionId == null) return;
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) return;
        
        if (currentSession.CheckedScripts.Contains(scriptName))
        {
            currentSession.CheckedScripts.Remove(scriptName);
        }
        else
        {
            currentSession.CheckedScripts.Add(scriptName);
        }
        
        // グローバルのcheckedScriptsも更新
        checkedScripts = new HashSet<string>(currentSession.CheckedScripts);
        StateHasChanged();
        
        // セッション情報を保存
        _ = LocalStorageService.SaveSessionsAsync(sessions);
    }
    
    private async Task InitializeTaskRunnerTerminal()
    {
        try
        {
            if (taskRunnerTerminal != null)
            {
                return;
            }
            
            // DOM要素の存在を確認
            var elementExists = await JSRuntime.InvokeAsync<bool>("eval", @"
                !!document.getElementById('task-runner-terminal')
            ");
            
            
            if (!elementExists)
            {
                StateHasChanged();
                await Task.Delay(200); // DOM更新を待つ
                
                // 再度確認
                elementExists = await JSRuntime.InvokeAsync<bool>("eval", @"
                    !!document.getElementById('task-runner-terminal')
                ");
            }
            
            // 新しいXTermを作成
            taskRunnerTerminal = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "terminalFunctions.createMultiSessionTerminal",
                "task-runner-terminal",
                "task-runner-terminal",
                dotNetRef
            );
            
            
            // 初期メッセージを表示
            if (taskRunnerTerminal != null)
            {
                await taskRunnerTerminal.InvokeVoidAsync("write", "タスクランナーターミナル準備完了\r\n");
            }
            
            // 初期化完了フラグを設定
            TaskRunnerInitialized = true;
        }
        catch (Exception ex)
        {
            toast?.ShowError($"タスクランナーターミナルの初期化エラー: {ex.Message}");
        }
    }
    
    private async Task CleanupTaskRunnerTerminal()
    {
        try
        {
            if (taskRunnerTerminal != null)
            {
                try
                {
                    // JavaScript側で破棄（JavaScript interopが利用可能な場合のみ）
                    await JSRuntime.InvokeVoidAsync("eval", @"
                        (function() {
                            const terminalId = 'task-runner-terminal';
                            const termObj = window.multiSessionTerminals && window.multiSessionTerminals[terminalId];
                            if (termObj) {
                                termObj.terminal.dispose();
                                delete window.multiSessionTerminals[terminalId];
                            }
                        })()
                    ");
                }
                catch (JSDisconnectedException)
                {
                    // JavaScript接続が切断されている場合は無視
                }
                catch (InvalidOperationException)
                {
                    // JavaScript interopが利用できない場合は無視
                }
                
                try
                {
                    await taskRunnerTerminal.DisposeAsync();
                }
                catch (JSDisconnectedException)
                {
                    // JavaScript接続が切断されている場合は無視
                }
                
                taskRunnerTerminal = null;
                TaskRunnerInitialized = false;
            }
        }
        catch (Exception)
        {
            // エラーは無視（Dispose時のエラーは致命的ではない）
        }
    }
    
    private async Task RunSelectedScript()
    {
        
        if (string.IsNullOrEmpty(selectedScript) || activeSessionId == null)
        {
            return;
        }
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null)
        {
            return;
        }
        
        try
        {
            
            // TaskManagerServiceの作業ディレクトリを設定
            TaskManagerService.WorkingDirectory = currentSession.FolderPath ?? Environment.CurrentDirectory;
            
            // TaskManagerServiceを使用してタスクを開始
            var taskSession = await TaskManagerService.StartTaskAsync(selectedScript);
            
            if (taskSession == null)
            {
                toast?.ShowError("タスクの開始に失敗しました");
                return;
            }
            
            
            // ターミナルをクリアして出力バッファの内容を表示
            if (taskRunnerTerminal != null)
            {
                await taskRunnerTerminal.InvokeVoidAsync("clear");
                
                // 既存の出力バッファの内容を表示（コピーを作成してからイテレーション）
                var outputLines = taskSession.OutputBuffer.ToList();
                foreach (var line in outputLines)
                {
                    await taskRunnerTerminal.InvokeVoidAsync("write", line);
                }
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            toast?.ShowError($"スクリプト実行エラー: {ex.Message}");
            StateHasChanged();
        }
    }
    
    private async Task StopSelectedScript()
    {
        if (string.IsNullOrEmpty(selectedScript)) return;
        
        
        // TaskManagerServiceを使用してタスクを停止
        var taskSession = GetTaskSessionByScriptName(selectedScript);
        if (taskSession != null)
        {
            await TaskManagerService.StopTaskAsync(taskSession.Id);
        }
        
        StateHasChanged();
        
        if (taskRunnerTerminal != null && taskSession?.IsTerminalConnected == true)
        {
            await taskRunnerTerminal.InvokeVoidAsync("write", "\r\n\x1b[91mタスクを停止しました\x1b[0m\r\n");
        }
    }
    
    // 実行（ターミナル付き）
    private async Task RunTaskWithTerminal(string scriptName)
    {
        
        selectedScript = scriptName;
        
        if (activeSessionId == null) return;
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) return;
        
        try
        {
            // TaskManagerServiceの作業ディレクトリを設定
            TaskManagerService.WorkingDirectory = currentSession.FolderPath ?? Environment.CurrentDirectory;
            
            // タスクを開始
            var taskSession = await TaskManagerService.StartTaskAsync(scriptName);
            
            if (taskSession == null)
            {
                toast?.ShowError("タスクの開始に失敗しました");
                return;
            }
            
            // ターミナルを接続
            taskSession.IsTerminalConnected = true;
            
            // npmコマンドをまだ送信していない場合は送信
            if (!taskSession.IsCommandSent && taskSession.ConPtySession != null)
            {
                var npmCommand = $"npm run {scriptName}\r";
                await taskSession.ConPtySession.WriteAsync(npmCommand);
                taskSession.IsCommandSent = true;
                taskSession.Status = TaskStatus.Running;
                taskSession.StartTime = DateTime.Now;
            }
            
            // XTermが初期化されていない場合は初期化
            if (!TaskRunnerInitialized)
            {
                await InitializeTaskRunnerTerminal();
            }
            
            // ターミナルをクリアして出力バッファの内容を表示
            if (taskRunnerTerminal != null)
            {
                await taskRunnerTerminal.InvokeVoidAsync("clear");
                
                // 現在のターミナルサイズを取得してConPtySessionに反映
                try
                {
                    var terminalSize = await taskRunnerTerminal.InvokeAsync<System.Text.Json.JsonElement>("getSize");
                    if (terminalSize.TryGetProperty("cols", out var colsElement) && 
                        terminalSize.TryGetProperty("rows", out var rowsElement))
                    {
                        int cols = colsElement.GetInt32();
                        int rows = rowsElement.GetInt32();
                        TaskManagerService.ResizeSession(taskSession.Id, cols, rows);
                    }
                }
                catch (Exception)
                {
                    // Ignore terminal size retrieval errors
                }
                
                // OutputBufferのコピーを作成してからイテレーション（同時変更を防ぐ）
                var outputLines = taskSession.OutputBuffer.ToList();
                foreach (var line in outputLines)
                {
                    await taskRunnerTerminal.InvokeVoidAsync("write", line);
                }
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            toast?.ShowError($"エラー: {ex.Message}");
        }
    }
    
    // 実行のみ（バックグラウンド）
    private async Task RunTaskBackground(string scriptName)
    {
        
        if (activeSessionId == null) return;
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) return;
        
        try
        {
            // TaskManagerServiceの作業ディレクトリを設定
            TaskManagerService.WorkingDirectory = currentSession.FolderPath ?? Environment.CurrentDirectory;
            
            // タスクを開始（ターミナルなし）
            var taskSession = await TaskManagerService.StartTaskAsync(scriptName);
            
            if (taskSession == null)
            {
                toast?.ShowError("タスクの開始に失敗しました");
                return;
            }
            
            // ターミナルは接続しない
            taskSession.IsTerminalConnected = false;
            
            // npmコマンドを送信してタスクを開始（バックグラウンドで実行）
            if (!taskSession.IsCommandSent && taskSession.ConPtySession != null)
            {
                var npmCommand = $"npm run {scriptName}\r";
                await taskSession.ConPtySession.WriteAsync(npmCommand);
                taskSession.IsCommandSent = true;
                taskSession.Status = TaskStatus.Running;
                taskSession.StartTime = DateTime.Now;
            }
            
            toast?.ShowSuccess($"{scriptName} をバックグラウンドで実行開始しました");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            toast?.ShowError($"エラー: {ex.Message}");
        }
    }
    
    // ターミナル接続
    private async Task ConnectTerminal(string scriptName)
    {
        
        var taskSession = GetTaskSessionByScriptName(scriptName);
        if (taskSession == null || (taskSession.Status != TaskStatus.Running && taskSession.Status != TaskStatus.Idle))
        {
            toast?.ShowWarning("接続可能なタスクが見つかりません");
            return;
        }
        
        try
        {
            // 選択中のスクリプトを更新
            selectedScript = scriptName;
            
            // ターミナルを接続
            taskSession.IsTerminalConnected = true;
            
            // npmコマンドをまだ送信していない場合は送信
            if (!taskSession.IsCommandSent && taskSession.ConPtySession != null)
            {
                var npmCommand = $"npm run {scriptName}\r";
                await taskSession.ConPtySession.WriteAsync(npmCommand);
                taskSession.IsCommandSent = true;
                taskSession.Status = TaskStatus.Running;
                taskSession.StartTime = DateTime.Now;
            }
            
            // TaskManagerServiceのアクティブセッションを設定
            TaskManagerService.SetActiveSession(taskSession.Id);
            
            // XTermが初期化されていない場合は初期化
            if (!TaskRunnerInitialized)
            {
                await InitializeTaskRunnerTerminal();
            }
            
            // ターミナルをクリアして出力バッファの内容を表示
            if (taskRunnerTerminal != null)
            {
                await taskRunnerTerminal.InvokeVoidAsync("clear");
                await taskRunnerTerminal.InvokeVoidAsync("write", $"\x1b[94m=== タスク '{scriptName}' に接続しました ===\x1b[0m\r\n");
                
                // 現在のターミナルサイズを取得してConPtySessionに反映
                try
                {
                    var terminalSize = await taskRunnerTerminal.InvokeAsync<System.Text.Json.JsonElement>("getSize");
                    if (terminalSize.TryGetProperty("cols", out var colsElement) && 
                        terminalSize.TryGetProperty("rows", out var rowsElement))
                    {
                        int cols = colsElement.GetInt32();
                        int rows = rowsElement.GetInt32();
                        TaskManagerService.ResizeSession(taskSession.Id, cols, rows);
                    }
                }
                catch (Exception)
                {
                    // Ignore terminal size retrieval errors
                }
                
                // 既存の出力バッファを表示
                // OutputBufferのコピーを作成してからイテレーション（同時変更を防ぐ）
                var outputLines = taskSession.OutputBuffer.ToList();
                foreach (var line in outputLines)
                {
                    await taskRunnerTerminal.InvokeVoidAsync("write", line);
                }
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            toast?.ShowError($"エラー: {ex.Message}");
        }
    }
    
    // ターミナル切断
    private async Task DisconnectTerminal(string scriptName)
    {
        
        var taskSession = GetTaskSessionByScriptName(scriptName);
        if (taskSession == null)
        {
            return;
        }
        
        try
        {
            // ターミナルを切断
            taskSession.IsTerminalConnected = false;
            
            // ターミナルに切断メッセージを表示
            if (taskRunnerTerminal != null && selectedScript == scriptName)
            {
                await taskRunnerTerminal.InvokeVoidAsync("write", $"\r\n\x1b[93m=== ターミナルを切断しました（タスクは実行継続中） ===\x1b[0m\r\n");
            }
            
            toast?.ShowInfo($"{scriptName} のターミナルを切断しました（タスクは実行継続中）");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            toast?.ShowError($"エラー: {ex.Message}");
        }
    }
    
    // TaskSessionをスクリプト名から取得するヘルパーメソッド
    private TaskSession? GetTaskSessionByScriptName(string scriptName)
    {
        // 現在のセッションのフォルダパスを取得
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null)
        {
            return null;
        }
        
        var currentFolderPath = currentSession.FolderPath ?? Directory.GetCurrentDirectory();
        
        // スクリプト名と作業ディレクトリの両方で検索
        return TaskManagerService.Sessions.FirstOrDefault(s => 
            s.ScriptName == scriptName && 
            s.WorkingDirectory == currentFolderPath);
    }
    
    // 現在は直接イベントハンドラーで処理しているため、このメソッドは使用されない
    private void OnTaskRunnerDataReceived(string data)
    {
        // 互換性のため残しているが、実際には使用されない
    }
    
    private void OnTaskRunnerExited(string scriptName)
    {
        InvokeAsync(async () =>
        {
            
            // TaskManagerServiceのセッションステータスは自動的に更新される
            // ターミナルに完了メッセージを表示
            if (selectedScript == scriptName && taskRunnerTerminal != null)
            {
                var taskSession = GetTaskSessionByScriptName(scriptName);
                if (taskSession != null)
                {
                    if (taskSession.Status == TaskStatus.Completed)
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", "\r\n\x1b[92mタスクが完了しました\x1b[0m\r\n");
                    }
                    else if (taskSession.Status == TaskStatus.Failed)
                    {
                        await taskRunnerTerminal.InvokeVoidAsync("write", $"\r\n\x1b[91mタスクが失敗しました (終了コード: {taskSession.ExitCode})\x1b[0m\r\n");
                    }
                }
            }
            
            StateHasChanged();
        });
    }
    
    private async void OnTaskButtonClick(string scriptName)
    {
        try
        {
            await RunScriptFromTextInput(scriptName);
        }
        catch (Exception ex)
        {
            toast?.ShowError($"タスク実行エラー: {ex.Message}");
        }
    }
    
    private async void StopTaskFromTextInput(string scriptName)
    {
        try
        {
            var taskSession = GetTaskSessionByScriptName(scriptName);
            if (taskSession != null)
            {
                await TaskManagerService.StopTaskAsync(taskSession.Id);
                toast?.ShowSuccess($"{scriptName} を停止しました");
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            toast?.ShowError($"タスク停止エラー: {ex.Message}");
        }
    }
    
    private async Task RunScriptFromTextInput(string scriptName, string additionalArgs = "")
    {
        
        if (activeSessionId == null) 
        {
            return;
        }
        
        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null) 
        {
            return;
        }
        
        try
        {
            // TaskManagerServiceの作業ディレクトリを設定
            TaskManagerService.WorkingDirectory = currentSession.FolderPath ?? Environment.CurrentDirectory;
            
            // タスクを開始（バックグラウンド実行と同じ - ターミナルなし）
            var taskSession = await TaskManagerService.StartTaskAsync(scriptName);
            
            if (taskSession == null)
            {
                toast?.ShowError("タスクの開始に失敗しました");
                return;
            }
            
            // ターミナルは接続しない（バックグラウンド実行）
            taskSession.IsTerminalConnected = false;
            
            // ターミナルは接続していないので、ActiveSessionは設定しても問題ない
            // ただし、バックグラウンド実行の場合は設定しない方が良い（SessionDataReceivedイベントの処理を避けるため）
            // TaskManagerService.SetActiveSession(taskSession.Id); // バックグラウンド実行なので設定しない
            
            // selectedScriptは設定しても良い（タスクランナータブで選択状態を表示するため）
            selectedScript = scriptName;
            
            // npmコマンドを送信してタスクを開始（バックグラウンドで実行）
            if (!taskSession.IsCommandSent && taskSession.ConPtySession != null)
            {
                // 追加引数がある場合はコマンドに追加
                var npmCommand = string.IsNullOrWhiteSpace(additionalArgs) 
                    ? $"npm run {scriptName}\r"
                    : $"npm run {scriptName} -- {additionalArgs}\r";
                    
                await taskSession.ConPtySession.WriteAsync(npmCommand);
                taskSession.IsCommandSent = true;
                taskSession.Status = TaskStatus.Running;
                taskSession.StartTime = DateTime.Now;
            }
            
            var message = string.IsNullOrWhiteSpace(additionalArgs)
                ? $"{scriptName} をバックグラウンドで実行開始しました"
                : $"{scriptName} を引数 '{additionalArgs}' でバックグラウンド実行開始しました";
            toast?.ShowSuccess(message);
            
            // タスクランナータブへの切り替えはしない（現在のタブのまま）
            // ユーザーが確認したい場合は手動でタスクランナータブに切り替える
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            toast?.ShowError($"タスク実行エラー: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        // ConPtyConnectionServiceのイベントハンドラーを削除
        if (_dataReceivedHandler != null)
        {
            ConPtyConnection.DataReceived -= _dataReceivedHandler;
            _dataReceivedHandler = null;
        }
        if (_processExitedHandler != null)
        {
            ConPtyConnection.ProcessExited -= _processExitedHandler;
            _processExitedHandler = null;
        }

        // JavaScript interopを安全に処理
        try
        {
            // 履歴を保存（JavaScript interopを使用）
            await InputHistoryService.SaveHistoryAsync();
        }
        catch (JSDisconnectedException)
        {
            // 回路が切断されている場合は無視
        }
        catch (Exception)
        {
            // その他のエラーも無視
        }
        
        // 単一DOSターミナルのクリーンアップ
        await CleanupSingleDosTerminal();
        
        // タスクランナーターミナルのクリーンアップ
        await CleanupTaskRunnerTerminal();
        
        // TaskManagerServiceのイベントハンドラーを削除
        if (_taskDataReceivedHandler != null)
        {
            TaskManagerService.SessionDataReceived -= _taskDataReceivedHandler;
            _taskDataReceivedHandler = null;
        }
        if (_taskSessionUpdatedHandler != null)
        {
            TaskManagerService.SessionUpdated -= _taskSessionUpdatedHandler;
            _taskSessionUpdatedHandler = null;
        }

        // HookNotificationServiceのイベントハンドラーを削除
        if (_hookNotificationHandler != null)
        {
            HookNotificationService.OnHookNotification -= _hookNotificationHandler;
            _hookNotificationHandler = null;
        }

        // SessionManagerのイベントハンドラーを削除
        if (_sessionsChangedHandler != null)
        {
            SessionManager.OnSessionsChanged -= _sessionsChangedHandler;
            _sessionsChangedHandler = null;
        }

        // TaskManagerServiceのクリーンアップ
        await TaskManagerService.StopAllTasksAsync();
        TaskManagerService.Dispose();
        
        // 全セッションのDOS ConPTYセッションのクリーンアップ（ハンドラー解除後に破棄）
        foreach (var session in sessions)
        {
            CleanupDosTerminalHandlers(session.SessionId, session.DosTerminalConPtySession);
            session.DosTerminalConPtySession?.Dispose();
        }
        
        // activeTerminalのDisposeを安全に処理
        if (activeTerminal != null)
        {
            try
            {
                await activeTerminal.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // 回路が切断されている場合は無視
            }
            catch (Exception)
            {
                // その他のエラーも無視
            }
        }
        
        dotNetRef?.Dispose();
        
        // JavaScriptのイベントリスナーをクリーンアップ
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupKeyboardShortcuts");
        }
        catch (JSDisconnectedException)
        {
            // 回路が切断されている場合は無視
        }
        catch (Exception)
        {
            // Dispose時のエラーは無視
        }
    }
}
