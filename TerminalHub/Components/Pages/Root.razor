@page "/multisession"
@page "/"
@using TerminalHub.Components.Shared
@using TerminalHub.Constants
@using TerminalHub.Models
@using TerminalHub.Services
@using Microsoft.JSInterop
@using Microsoft.Extensions.Configuration
@inject ISessionManager SessionManager
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorageService
@inject IConfiguration Configuration
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>マルチセッション ターミナル</PageTitle>

<Toast @ref="toast" />
<SessionCreateDialog IsVisible="showCreateDialog" 
                    OnSessionCreate="OnSessionCreate" 
                    OnCancel="OnDialogCancel" />
<DevWindow @bind-IsVisible="showDevWindow" />

<div class="container-fluid h-100">
    <div class="row h-100">
        <div class="col-md-3 border-end bg-light p-3 d-flex flex-column" style="height: 100vh;">
            
            <div class="mb-3">
                <button class="btn btn-primary w-100" @onclick="AddSession" disabled="@isAddingSession">
                    <i class="bi bi-plus-circle"></i> 新しいセッションを作成
                </button>
            </div>

            <div class="list-group flex-grow-1" style="overflow-y: auto;">
                @foreach (var session in sessions)
                {
                    <div class="list-group-item list-group-item-action @(session.SessionId == activeSessionId ? "active" : "")" 
                         @onclick="() => SelectSession(session.SessionId)"
                         style="cursor: pointer;">
                        <div class="d-flex w-100 justify-content-between align-items-center">
                            <div class="flex-fill">
                                <h6 class="mb-1">
                                    @session.GetDisplayName()
                                    @if (session.TerminalType != TerminalType.Terminal)
                                    {
                                        <span class="badge bg-info ms-2">@GetTerminalTypeBadge(session.TerminalType)</span>
                                    }
                                </h6>
                                @if (!string.IsNullOrEmpty(session.ProcessingStatus))
                                {
                                    <div>
                                        <small class="text-warning">
                                            <i class="bi bi-clock-fill me-1"></i>@session.ProcessingStatus
                                        </small>
                                    </div>
                                }
                            </div>
                            <button class="btn btn-danger btn-sm" @onclick:stopPropagation="true" 
                                    @onclick="() => RemoveSession(session.SessionId)"
                                    title="セッション削除">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                        <div class="mt-2">
                            @if (editingMemoSessionId == session.SessionId)
                            {
                                <input type="text" class="form-control form-control-sm" 
                                       placeholder="メモを入力..."
                                       value="@tempMemoText"
                                       @onclick:stopPropagation="true"
                                       @oninput="@((e) => tempMemoText = e.Value?.ToString() ?? "")"
                                       @onblur="@(async () => await SaveMemo(session.SessionId))"
                                       @onkeydown="@(async (e) => await HandleMemoKeyDown(e, session.SessionId))"
                                       @onkeydown:stopPropagation="true"
                                       style="font-size: 0.875rem;" 
                                       autofocus />
                            }
                            else
                            {
                                <div class="text-muted small" 
                                     @onclick:stopPropagation="true"
                                     @onclick="() => StartEditingMemo(session.SessionId, session.Memo)"
                                     style="cursor: pointer; font-size: 0.875rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; background-color: rgba(0,0,0,0.03);">
                                    @if (string.IsNullOrWhiteSpace(session.Memo))
                                    {
                                        <span style="font-style: italic; opacity: 0.6;">メモを追加...</span>
                                    }
                                    else
                                    {
                                        @session.Memo
                                    }
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>

            @if (!sessions.Any())
            {
                <div class="alert alert-info mt-3">
                    <i class="bi bi-info-circle"></i> ボタンをクリックしてセッションを作成してください
                </div>
            }

            <!-- ショートカット説明を最下部に固定 -->
            <div class="mt-auto p-2 border-top" style="font-size: 0.8rem; color: #6c757d; position: sticky; bottom: 0; background-color: #f8f9fa;">
                <p class="mb-1"><strong>ショートカット:</strong></p>
                <p class="mb-0"><kbd>Ctrl+Shift+N</kbd> - 新しいセッション</p>
                <p class="mb-0"><kbd>Ctrl+Shift+D</kbd> - デバッグ情報 (コンソール)</p>
                <p class="mb-0"><kbd>Ctrl+Shift+C</kbd> - ストレージクリア</p>
            </div>
        </div>

        <div class="col-md-9 p-0 position-relative" style="height: 100vh; display: flex; flex-direction: column;">
            @if (activeSessionId != null)
            {
                <!-- ターミナル部分 (70%) -->
                <div style="height: 70%; overflow: hidden;">
                    <div class="terminal-wrapper h-100">
                        @foreach (var session in sessions)
                        {
                            <div id="terminal-@session.SessionId" class="terminal-container" 
                                 style="display: @(session.SessionId == activeSessionId ? "block" : "none");"></div>
                        }
                    </div>
                </div>
                
                <!-- WebUI部分 (30%) -->
                <div style="height: 30%; overflow-y: auto; border-top: 1px solid #dee2e6; background-color: #f8f9fa;">
                    @{
                        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
                    }
                    @if (currentSession != null && (currentSession.TerminalType == TerminalType.ClaudeCode || currentSession.TerminalType == TerminalType.GeminiCLI))
                    {
                        <div class="p-3 h-100 d-flex flex-column">
                            
                            <div class="flex-grow-1 d-flex flex-column">
                                <textarea class="form-control flex-grow-1" 
                                          @bind="inputText"
                                          @bind:event="oninput"
                                          @onkeydown="OnTextAreaKeyDown"
                                          @onkeydown:preventDefault="@shouldPreventDefault"
                                          placeholder="@(GetPlaceholderText(currentSession.TerminalType))"
                                          style="resize: none; font-family: 'Consolas', 'Monaco', monospace;">
                                </textarea>
                                
                                <div class="mt-2 d-flex justify-content-between align-items-center">
                                    <div>
                                        <kbd>Enter</kbd> で送信 | <kbd>Shift+Enter</kbd> で改行
                                    </div>
                                    <div class="btn-group">
                                        <button class="btn btn-secondary @(isEscapePressed ? "active" : "")" 
                                                @onclick="SendEscape" 
                                                title="中断 (Esc)"
                                                style="@(isEscapePressed ? "transform: scale(0.95);" : "")">
                                            <i class="bi bi-stop-circle"></i> 中断
                                        </button>
                                        @if (currentSession.TerminalType == TerminalType.ClaudeCode)
                                        {
                                            <button class="btn btn-secondary @(isModeSwitchPressed ? "active" : "")" 
                                                    @onclick="SendModeSwitch" 
                                                    title="モード切替 (Alt+M)"
                                                    style="@(isModeSwitchPressed ? "transform: scale(0.95);" : "")">
                                                <i class="bi bi-arrow-repeat"></i> Alt+M
                                            </button>
                                        }
                                        @if (showDevButton)
                                        {
                                            <button class="btn btn-secondary" 
                                                    @onclick="() => showDevWindow = !showDevWindow" 
                                                    title="開発ツール">
                                                <i class="bi bi-code-square"></i> Dev
                                            </button>
                                        }
                                        <button class="btn btn-primary" @onclick="SendInput" disabled="@(string.IsNullOrWhiteSpace(inputText))">
                                            <i class="bi bi-send"></i> 送信
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="p-3 text-center text-muted">
                            <p>このセッションタイプではWebUIは使用できません</p>
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="d-flex align-items-center justify-content-center h-100">
                    <div class="text-center text-muted">
                        <i class="bi bi-terminal" style="font-size: 4rem;"></i>
                        <p class="mt-3">左側からセッションを選択してください</p>
                    </div>
                </div>
            }
        </div>
    </div>
</div>


@code {
    private List<SessionInfo> sessions = new();
    private string? activeSessionId;
    private bool isAddingSession = false;
    private bool showCreateDialog = false;
    private IJSObjectReference? activeTerminal;
    private ConPtySession? activeSession;
    private CancellationTokenSource? readCts;
    private DotNetObjectReference<Root>? dotNetRef;
    private Toast? toast;
    private string inputText = "";
    private bool shouldPreventDefault = false;
    private string? editingMemoSessionId = null;
    private string tempMemoText = "";
    private bool showDevWindow = false;
    private bool showDevButton = false;

    protected override async Task OnInitializedAsync()
    {
        dotNetRef = DotNetObjectReference.Create(this);
        
        // 開発モード設定を読み込み
        showDevButton = Configuration.GetValue<bool>("DevelopmentMode:ShowDevButton", false);
        showDevWindow = Configuration.GetValue<bool>("DevelopmentMode:ShowDevWindowOnStartup", false);
        
        // ローカルストレージからセッション情報を復元
        var savedSessions = await LocalStorageService.LoadSessionsAsync();
        var savedActiveId = await LocalStorageService.LoadActiveSessionIdAsync();
        
        // 保存されたセッション情報をSessionManagerに復元
        var restoredSessionIds = new HashSet<string>();
        foreach (var sessionInfo in savedSessions)
        {
            // 重複チェック（ホットリロード対策）
            var existingSession = SessionManager.GetSessionInfo(sessionInfo.SessionId);
            if (existingSession != null)
            {
                restoredSessionIds.Add(sessionInfo.SessionId);
                continue;
            }
            
            // セッションを再作成（ターミナルプロセスの起動）
            try
            {
                var newSession = await SessionManager.CreateSessionAsync(
                    sessionInfo.FolderPath,
                    sessionInfo.DisplayName,
                    sessionInfo.TerminalType,
                    sessionInfo.Options);
                    
                // メモ情報も復元
                if (!string.IsNullOrEmpty(sessionInfo.Memo))
                {
                    var createdSession = SessionManager.GetSessionInfo(newSession.SessionId);
                    if (createdSession != null)
                    {
                        createdSession.Memo = sessionInfo.Memo;
                        await SessionManager.SaveSessionInfoAsync(createdSession);
                    }
                }
                
                restoredSessionIds.Add(newSession.SessionId);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to restore session {sessionInfo.SessionId}: {ex.Message}");
            }
        }
        
        sessions = SessionManager.GetAllSessions().ToList();
        
        // 保存されたアクティブセッションがあれば選択
        if (savedActiveId != null && sessions.Any(s => s.SessionId == savedActiveId))
        {
            await SelectSession(savedActiveId);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // キーボードショートカットを登録
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setupKeyboardShortcuts", dotNetRef);
        }
    }

    [JSInvokable]
    public async Task OnShortcutNewSession()
    {
        await AddSession();
    }

    private async Task AddSession()
    {
        showCreateDialog = true;
    }

    private async Task OnSessionCreate(SessionCreateDialog.SessionCreateResult result)
    {
        showCreateDialog = false;
        isAddingSession = true;
        
        try
        {
            var sessionInfo = await SessionManager.CreateSessionAsync(
                result.FolderPath, 
                "", // セッション名は空（フォルダ名を使用）
                result.TerminalType, 
                result.Options);
            
            sessions = SessionManager.GetAllSessions().ToList();
            
            // ローカルストレージに保存
            await LocalStorageService.SaveSessionsAsync(sessions);
            
            StateHasChanged();
            
            await Task.Delay(TerminalConstants.DomUpdateDelay);
            await SelectSession(sessionInfo.SessionId);
        }
        catch (Exception ex)
        {
            toast?.ShowError($"セッション作成エラー: {ex.Message}");
        }
        finally
        {
            isAddingSession = false;
        }
    }

    private void OnDialogCancel()
    {
        showCreateDialog = false;
    }


    private async Task SelectSession(string sessionId)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        Console.WriteLine($"[SelectSession] 開始: sessionId={sessionId}, activeSessionId={activeSessionId}");
        
        if (activeSessionId == sessionId)
        {
            Console.WriteLine($"[SelectSession] 既に選択済み: {stopwatch.ElapsedMilliseconds}ms");
            return;
        }

        // 前のセッションをクリーンアップ
        var previousCts = readCts;
        readCts = null;
        
        if (previousCts != null)
        {
            var cleanupStart = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"[SelectSession] 前のセッションをクリーンアップ開始: {cleanupStart}ms");
            try
            {
                previousCts.Cancel();
                // キャンセル要求だけ送信して即座に次へ進む
            }
            finally
            {
                previousCts.Dispose();
            }
            Console.WriteLine($"[SelectSession] クリーンアップ完了: {stopwatch.ElapsedMilliseconds - cleanupStart}ms");
        }
        
        // 既存のアクティブターミナルを破棄
        if (activeTerminal != null)
        {
            var disposeStart = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"[SelectSession] 既存のアクティブターミナル破棄開始: {disposeStart}ms");
            try
            {
                await activeTerminal.DisposeAsync();
            }
            catch (Exception)
            {
                // Console.WriteLine($"[SelectSession] ターミナル破棄エラー: {ex.Message}");
            }
            activeTerminal = null;
            Console.WriteLine($"[SelectSession] ターミナル破棄完了: {stopwatch.ElapsedMilliseconds - disposeStart}ms");
        }
        
        // すべてのターミナルを非表示にする（JavaScriptで直接制御）
        var hideStart = stopwatch.ElapsedMilliseconds;
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalFunctions.hideAllTerminals");
            Console.WriteLine($"[SelectSession] すべてのターミナル非表示完了: {stopwatch.ElapsedMilliseconds - hideStart}ms");
        }
        catch (Exception)
        {
            Console.WriteLine($"[SelectSession] ターミナル非表示エラー: {stopwatch.ElapsedMilliseconds - hideStart}ms");
        }

        // セッションをアクティブに
        var activateStart = stopwatch.ElapsedMilliseconds;
        await SessionManager.SetActiveSessionAsync(sessionId);
        activeSessionId = sessionId;
        activeSession = SessionManager.GetSession(sessionId);
        
        // アクティブセッション変更を即座にUIに反映
        StateHasChanged();
        
        // アクティブセッションIDをローカルストレージに保存
        await LocalStorageService.SaveActiveSessionIdAsync(sessionId);
        Console.WriteLine($"[SelectSession] セッション設定完了: {stopwatch.ElapsedMilliseconds - activateStart}ms");

        // ターミナルdivが存在するか確認し、表示する
        var checkStart = stopwatch.ElapsedMilliseconds;
        try
        {
            var divExists = await JSRuntime.InvokeAsync<bool>("terminalHubHelpers.checkElementExists", 
                $"terminal-{sessionId}");
            Console.WriteLine($"[SelectSession] terminal-{sessionId} divの存在確認: {divExists}, {stopwatch.ElapsedMilliseconds - checkStart}ms");
            
            if (divExists)
            {
                var showStart = stopwatch.ElapsedMilliseconds;
                // 新しいターミナルを表示
                await JSRuntime.InvokeVoidAsync("terminalFunctions.showTerminal", sessionId);
                Console.WriteLine($"[SelectSession] ターミナル表示完了: {stopwatch.ElapsedMilliseconds - showStart}ms");
            }
        }
        catch (Exception)
        {
            Console.WriteLine($"[SelectSession] div確認エラー: {stopwatch.ElapsedMilliseconds - checkStart}ms");
        }

        // ターミナルを初期化
        var initStart = stopwatch.ElapsedMilliseconds;
        Console.WriteLine($"[SelectSession] InitializeTerminal開始: {initStart}ms");
        await InitializeTerminal(sessionId);
        Console.WriteLine($"[SelectSession] InitializeTerminal完了: {stopwatch.ElapsedMilliseconds - initStart}ms");
        
        // ターミナルのリサイズを強制的に実行
        var resizeStart = stopwatch.ElapsedMilliseconds;
        try
        {
            if (activeTerminal != null)
            {
                await activeTerminal.InvokeVoidAsync("resize");
                Console.WriteLine($"[SelectSession] ターミナルリサイズ完了: {stopwatch.ElapsedMilliseconds - resizeStart}ms");
            }
        }
        catch (Exception)
        {
            Console.WriteLine($"[SelectSession] リサイズエラー: {stopwatch.ElapsedMilliseconds - resizeStart}ms");
        }
        
        // 出力読み取りを開始
        if (activeSession != null)
        {
            var readStart = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"[SelectSession] ReadOutput開始: {readStart}ms");
            readCts = new CancellationTokenSource();
            _ = Task.Run(() => ReadOutput(readCts.Token));
        }
        
        Console.WriteLine($"[SelectSession] 全体完了: {stopwatch.ElapsedMilliseconds}ms");
    }

    private async Task InitializeTerminal(string sessionId)
    {
        var terminalId = $"terminal-{sessionId}";
        // Console.WriteLine($"[InitializeTerminal] 開始: terminalId={terminalId}");
        
        // JavaScript側の既存ターミナルも削除
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalFunctions.cleanupTerminal", sessionId);
        }
        catch { }
        
        // Console.WriteLine($"[InitializeTerminal] 新しいターミナルを作成");
        try
        {
            activeTerminal = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "terminalFunctions.createMultiSessionTerminal", 
                terminalId, 
                sessionId, 
                dotNetRef);
            
            // Console.WriteLine($"[InitializeTerminal] ターミナル作成成功");
        }
        catch (Exception)
        {
            // Console.WriteLine($"[InitializeTerminal] ターミナル作成エラー: {ex.Message}");
        }
    }

    private async Task ReadOutput(CancellationToken cancellationToken)
    {
        var localSessionId = activeSessionId; // ローカル変数にコピー
        // Console.WriteLine($"[ReadOutput] 開始: sessionId={localSessionId}");
        
        if (activeSession == null || activeTerminal == null)
        {
            // Console.WriteLine($"[ReadOutput] 条件不足で終了");
            return;
        }

        var buffer = new char[TerminalConstants.DefaultBufferSize];
        
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                // キャンセルが要求されているか再確認
                if (cancellationToken.IsCancellationRequested)
                    break;
                    
                var charsRead = await activeSession.ReadAsync(buffer, 0, buffer.Length);
                if (charsRead > 0)
                {
                    // データ書き込み前に再度キャンセルを確認
                    if (cancellationToken.IsCancellationRequested)
                        break;
                        
                    var data = new string(buffer, 0, charsRead);
                    // Console.WriteLine($"[ReadOutput] セッション {localSessionId} に {charsRead} 文字書き込み");
                    
                    // Claude Codeセッションの場合、処理状態を解析
                    var currentSession = sessions.FirstOrDefault(s => s.SessionId == localSessionId);
                    if (currentSession?.TerminalType == TerminalType.ClaudeCode)
                    {
                        // Claude Codeの処理状態パターンを検出
                        AnalyzeClaudeCodeOutput(data);
                    }
                    
                    await activeTerminal.InvokeVoidAsync("write", data);
                }
            }
            catch (Exception)
            {
                if (!cancellationToken.IsCancellationRequested)
                {
                    // Console.WriteLine($"[ReadOutput] 読み取りエラー: {ex.Message}");
                }
                break;
            }
        }
        
        // Console.WriteLine($"[ReadOutput] 終了: sessionId={localSessionId}");
    }

    private void StartEditingMemo(string sessionId, string currentMemo)
    {
        editingMemoSessionId = sessionId;
        tempMemoText = currentMemo ?? "";
    }

    private async Task SaveMemo(string sessionId)
    {
        if (editingMemoSessionId == sessionId)
        {
            await UpdateSessionMemo(sessionId, tempMemoText);
            editingMemoSessionId = null;
            tempMemoText = "";
        }
    }

    private async Task HandleMemoKeyDown(KeyboardEventArgs e, string sessionId)
    {
        if (e.Key == "Enter")
        {
            await SaveMemo(sessionId);
        }
        else if (e.Key == "Escape")
        {
            editingMemoSessionId = null;
            tempMemoText = "";
        }
    }

    private async Task UpdateSessionMemo(string sessionId, string memo)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            session.Memo = memo;
            // ローカルストレージを更新
            await LocalStorageService.SaveSessionsAsync(sessions);
        }
    }

    private async Task RemoveSession(string sessionId)
    {
        // アクティブセッションの場合、読み取りタスクを停止
        if (sessionId == activeSessionId)
        {
            var ctsToCancel = readCts;
            readCts = null;
            
            if (ctsToCancel != null)
            {
                try
                {
                    ctsToCancel.Cancel();
                    // キャンセル要求だけ送信して即座に次へ進む
                }
                finally
                {
                    ctsToCancel.Dispose();
                }
            }
            
            if (activeTerminal != null)
            {
                await activeTerminal.DisposeAsync();
                activeTerminal = null;
            }
        }
        
        // ターミナルのクリーンアップはdestroyTerminalで処理される
        
        await SessionManager.RemoveSessionAsync(sessionId);
        sessions = SessionManager.GetAllSessions().ToList();
        
        // ローカルストレージを更新
        await LocalStorageService.SaveSessionsAsync(sessions);
        
        if (activeSessionId == sessionId)
        {
            activeSessionId = null;
            activeSession = null;
            
            // セッション削除を即座にUIに反映
            StateHasChanged();
            
            await LocalStorageService.SaveActiveSessionIdAsync(null);
            
            // 他のセッションがあれば最初のものを選択
            if (sessions.Any())
            {
                await SelectSession(sessions.First().SessionId);
            }
        }
        else
        {
            // 削除されたセッションがアクティブでない場合もUIを更新
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task SendInput(string sessionId, string data)
    {
        if (activeSession != null && sessionId == activeSessionId)
        {
            await activeSession.WriteAsync(data);
        }
    }

    [JSInvokable]
    public void OnTerminalSizeChanged(string sessionId, int cols, int rows)
    {
        if (sessionId == activeSessionId && activeSession != null)
        {
            activeSession.Resize(cols, rows);
        }
    }

    private async Task DestroyTerminal(string sessionId, bool showAlert = true)
    {
        // Console.WriteLine($"[DestroyTerminal] セッション {sessionId} のターミナルを破棄");
        
        try
        {
            // JavaScript側のターミナルを破棄
            await JSRuntime.InvokeVoidAsync("terminalFunctions.destroyTerminal", sessionId);
            
            // C#側のターミナル参照を削除（アクティブセッションの場合のみ）
            if (activeSessionId == sessionId && activeTerminal != null)
            {
                await activeTerminal.DisposeAsync();
                activeTerminal = null;
                // Console.WriteLine($"[DestroyTerminal] C#側のターミナル参照を削除");
            }
            
            // アクティブセッションの場合は読み取り処理を停止
            if (activeSessionId == sessionId && readCts != null)
            {
                readCts.Cancel();
                readCts.Dispose();
                readCts = null;
                // Console.WriteLine($"[DestroyTerminal] 読み取り処理を停止");
            }
            
            if (showAlert)
            {
                toast?.ShowSuccess("ターミナルを破棄しました");
            }
        }
        catch (Exception ex)
        {
            // Console.WriteLine($"[DestroyTerminal] エラー: {ex.Message}");
            if (showAlert)
            {
                toast?.ShowError($"ターミナル破棄エラー: {ex.Message}");
            }
        }
    }

    private async Task RecreateTerminal(string sessionId)
    {
        // Console.WriteLine($"[RecreateTerminal] セッション {sessionId} のターミナルを再作成");
        
        try
        {
            // セッションがアクティブな場合のみ再作成
            if (activeSessionId == sessionId)
            {
                // 既存のターミナルを破棄（アラートなし）
                await DestroyTerminal(sessionId, false);
                
                // DOM更新と読み取りタスクの完全な終了を待つ
                await Task.Delay(TerminalConstants.SessionCreationDelay);
                
                // ターミナルdivの表示状態を確実に設定
                await JSRuntime.InvokeVoidAsync("terminalFunctions.ensureTerminalVisible", sessionId);
                
                // 新しいターミナルを初期化
                await InitializeTerminal(sessionId);
                
                // 読み取り処理を再開
                if (activeSession != null)
                {
                    readCts = new CancellationTokenSource();
                    _ = Task.Run(() => ReadOutput(readCts.Token));
                    // Console.WriteLine($"[RecreateTerminal] 読み取り処理を再開");
                    
                    // ターミナルに初期プロンプトを送信して接続を確認
                    if (activeTerminal != null)
                    {
                        // Enterキーを送信してプロンプトを表示
                        await activeSession.WriteAsync("\r\n");
                        // Console.WriteLine($"[RecreateTerminal] プロンプト送信完了");
                    }
                }
                
                toast?.ShowSuccess("ターミナルを再作成しました");
            }
            else
            {
                toast?.ShowWarning("このセッションを選択してからターミナルを再作成してください");
            }
        }
        catch (Exception ex)
        {
            // Console.WriteLine($"[RecreateTerminal] エラー: {ex.Message}");
            toast?.ShowError($"ターミナル再作成エラー: {ex.Message}");
        }
    }

    private string GetTerminalTypeBadge(TerminalType type)
    {
        return type switch
        {
            TerminalType.ClaudeCode => "Claude",
            TerminalType.GeminiCLI => "Gemini",
            _ => "Terminal"
        };
    }

    private void AnalyzeClaudeCodeOutput(string data)
    {
        try
        {
            // 処理状態パターンの検出
            var patterns = new[]
            {
                @"[·✽]\s*(.*?ing[^(]*)\s*\((\d+)s\s*·\s*([↑↓⚒])\s*(\d+)\s*tokens?\s*·\s*esc to interrupt\)",
                @"\[Request interrupted by user\]"
            };
            
            foreach (var pattern in patterns)
            {
                var regex = new System.Text.RegularExpressions.Regex(pattern);
                var matches = regex.Matches(data);
                
                foreach (System.Text.RegularExpressions.Match match in matches)
                {
                    if (pattern.Contains("Request interrupted"))
                    {
                        Console.WriteLine("[Claude Code Status] 処理が中断されました");
                        UpdateSessionProcessingStatus(null);
                    }
                    else if (match.Groups.Count >= 5)
                    {
                        var action = match.Groups[1].Value.Trim();
                        var seconds = match.Groups[2].Value;
                        var direction = match.Groups[3].Value;
                        var tokens = match.Groups[4].Value;
                        
                        var directionText = direction switch
                        {
                            "↑" => "送信",
                            "↓" => "受信", 
                            "⚒" => "処理中",
                            _ => direction
                        };
                        
                        var statusText = $"{seconds}秒 · {directionText} {tokens}トークン";
                        Console.WriteLine($"[Claude Code Status] {action} - {statusText}");
                        UpdateSessionProcessingStatus(statusText);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Claude Code Analysis Error] {ex.Message}");
        }
    }

    private void UpdateSessionProcessingStatus(string? statusText)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (session != null)
        {
            Console.WriteLine($"[UI Update] セッション {activeSessionId} の処理状態を更新: {statusText ?? "null"}");
            
            session.ProcessingStatus = statusText;
            if (statusText != null)
            {
                session.ProcessingStartTime = DateTime.Now;
            }
            else
            {
                session.ProcessingStartTime = null;
            }
            
            // UIスレッドで強制的に更新
            try
            {
                InvokeAsync(StateHasChanged);
                Console.WriteLine("[UI Update] StateHasChanged実行完了");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[StateHasChanged Error] {ex.Message}");
            }
        }
        else
        {
            Console.WriteLine($"[UI Update] アクティブセッション {activeSessionId} が見つかりません");
        }
    }

    private async Task SendInput()
    {
        if (string.IsNullOrWhiteSpace(inputText) || activeSession == null)
            return;

        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null)
            return;

        // テキストを送信
        await activeSession.WriteAsync(inputText);
        
        // 送信後にEnterキーを送信
        await SendEnterKeyDirect();
        
        // 入力フィールドをクリア
        inputText = "";
    }

    private async Task OnTextAreaKeyDown(KeyboardEventArgs e)
    {
        // Enter で送信（Shiftキーが押されていない場合）
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            shouldPreventDefault = true;
            await SendInput();
            shouldPreventDefault = false;
        }
        else
        {
            shouldPreventDefault = false;
        }
        // Shift+Enter は通常の改行動作（何もしない）
    }

    private string GetPlaceholderText(TerminalType terminalType)
    {
        return terminalType == TerminalType.ClaudeCode 
            ? "Claude Codeへのメッセージを入力..." 
            : "Gemini CLIへのメッセージを入力...";
    }

    private bool isEscapePressed = false;
    private bool isModeSwitchPressed = false;

    private async Task SendEscape()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isEscapePressed = true;

        // Escキーを送信（\x1B はESCのエスケープシーケンス）
        await activeSession.WriteAsync("\x1B");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isEscapePressed = false;
    }

    private async Task SendModeSwitch()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isModeSwitchPressed = true;

        // Alt+M を送信（\x1B はESC、m はM）
        await activeSession.WriteAsync("\x1Bm");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isModeSwitchPressed = false;
    }


    private async Task SendEnterKeyDirect()
    {
        if (activeSession == null)
            return;

        // 様々なEnterキーのパターンを試す
        // Windows環境では通常 \r\n だが、ターミナルによって異なる場合がある
        await activeSession.WriteAsync("\r");
    }


    public async ValueTask DisposeAsync()
    {
        var ctsToDispose = readCts;
        readCts = null;
        
        if (ctsToDispose != null)
        {
            try
            {
                ctsToDispose.Cancel();
            }
            finally
            {
                ctsToDispose.Dispose();
            }
        }
        
        if (activeTerminal != null)
        {
            await activeTerminal.DisposeAsync();
        }
        
        dotNetRef?.Dispose();
        
        // JavaScriptのイベントリスナーをクリーンアップ
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupKeyboardShortcuts");
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupDevWindowDrag");
        }
        catch (Exception)
        {
            // Dispose時のエラーは無視
        }
    }
}
