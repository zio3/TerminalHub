@page "/multisession"
@page "/"
@using TerminalHub.Components.Shared
@using TerminalHub.Components.Shared.Dialogs
@using TerminalHub.Constants
@using TerminalHub.Models
@using TerminalHub.Services
@using TerminalHub.Analyzers
@using Microsoft.JSInterop
@using Microsoft.Extensions.Configuration
@inject ISessionManager SessionManager
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorageService
@inject IConfiguration Configuration
@inject INotificationService NotificationService
@inject IOutputAnalyzerFactory AnalyzerFactory
@inject IGitService GitService
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>マルチセッション ターミナル</PageTitle>

<Toast @ref="toast" />
<SessionCreateDialog IsVisible="showCreateDialog" 
                    OnSessionCreate="OnSessionCreate" 
                    OnCancel="OnDialogCancel" />
<DevWindow @ref="devWindow" @bind-IsVisible="showDevWindow" />
<SettingsDialog @bind-IsVisible="showSettingsDialog" />
<SubSessionDialog IsVisible="showSubSessionDialog" 
                         ParentSessionName="@subSessionParentSessionName"
                         ParentSessionId="@subSessionParentSessionId"
                         ParentSessionPath="@subSessionParentSessionPath"
                         IsGitRepository="@subSessionParentSessionIsGitRepository"
                         OnSubSessionOperation="OnSubSessionOperation" 
                         OnCancel="() => showSubSessionDialog = false" />
<SessionSettingsDialog IsVisible="showSessionSettingsDialog"
                       SessionId="@settingsSessionId"
                       OnSettingsSaved="OnSessionSettingsSaved"
                       OnCancel="() => showSessionSettingsDialog = false" />

<div class="container-fluid h-100">
    <div class="row h-100">
        <SessionList Sessions=@sessions
                     ActiveSessionId=@activeSessionId
                     IsAddingSession=@isAddingSession
                     EditingMemoSessionId=@editingMemoSessionId
                     TempMemoText=@tempMemoText
                     OnAddSession="AddSession"
                     OnSessionSelect="async (sessionId) => await SelectSession(sessionId)"
                     OnSessionRemove="async (sessionId) => await RemoveSession(sessionId)"
                     OnMemoInput="(text) => tempMemoText = text"
                     OnMemoSave="SaveMemo"
                     OnMemoKeyDown="HandleMemoKeyDown"
                     OnMemoEdit="StartEditingMemo"
                     OnSettingsClick="ShowSettings"
                     OnCreateWorktree="ShowWorktreeDialog"
                     OnSessionSettings="ShowSessionSettingsDialog"
                     OnGitStatusRefresh="RefreshGitStatus" />

        <div class="col-md-9 p-0 position-relative" style="height: 100vh; display: flex; flex-direction: column;">
            @if (activeSessionId != null)
            {
                <!-- ターミナル部分 (70%) -->
                <div style="height: 70%; overflow: hidden;">
                    <div class="terminal-wrapper h-100">
                        @foreach (var session in sessions)
                        {
                            <div id="terminal-@session.SessionId" class="terminal-container" 
                                 style="display: @(session.SessionId == activeSessionId ? "block" : "none");"></div>
                        }
                    </div>
                </div>
                
                <!-- WebUI部分 (30%) -->
                <div style="height: 30%; overflow-y: auto; border-top: 1px solid #dee2e6; background-color: #f8f9fa;">
                    @{
                        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
                    }
                    @if (currentSession != null && (currentSession.TerminalType == TerminalType.ClaudeCode || currentSession.TerminalType == TerminalType.GeminiCLI))
                    {
                        <div class="p-3 h-100 d-flex flex-column">
                            
                            <div class="flex-grow-1 d-flex flex-column">
                                <textarea id="inputText" 
                                          class="form-control flex-grow-1" 
                                          data-input-area
                                          @bind="inputText"
                                          @bind:event="oninput"
                                          @onkeydown="OnTextAreaKeyDown"
                                          @onkeydown:preventDefault="@shouldPreventDefault"
                                          placeholder="@(GetPlaceholderText(currentSession.TerminalType))"
                                          style="resize: none; font-family: 'Consolas', 'Monaco', monospace;">
                                </textarea>
                                
                                <div class="mt-2 d-flex justify-content-between align-items-center">
                                    <div>
                                        <kbd>Enter</kbd> で送信 | <kbd>Shift+Enter</kbd> で改行 | <kbd>Ctrl+↑↓</kbd> で履歴
                                    </div>
                                    <div class="btn-group">
                                        <button class="btn btn-secondary @(isCtrlCPressed ? "active" : "")" 
                                                @onclick="SendCtrlC" 
                                                title="強制中断 (Ctrl+C)"
                                                style="@(isCtrlCPressed ? "transform: scale(0.95);" : "")">
                                            <i class="bi bi-x-octagon"></i> Ctrl+C
                                        </button>
                                        <button class="btn btn-secondary @(isEscapePressed ? "active" : "")" 
                                                @onclick="SendEscape" 
                                                title="中断 (Esc)"
                                                style="@(isEscapePressed ? "transform: scale(0.95);" : "")">
                                            <i class="bi bi-stop-circle"></i> Esc
                                        </button>
                                        @if (currentSession.TerminalType == TerminalType.ClaudeCode)
                                        {
                                            <button class="btn btn-secondary @(isModeSwitchPressed ? "active" : "")" 
                                                    @onclick="SendModeSwitch" 
                                                    title="モード切替 (Alt+M)"
                                                    style="@(isModeSwitchPressed ? "transform: scale(0.95);" : "")">
                                                <i class="bi bi-arrow-repeat"></i> Alt+M
                                            </button>
                                        }
                                        @if (showDevButton)
                                        {
                                            <button class="btn btn-secondary" 
                                                    @onclick="ToggleDevWindow" 
                                                    title="開発ツール">
                                                <i class="bi bi-code-square"></i> Dev
                                            </button>
                                        }
                                        <button class="btn btn-primary" @onclick="SendInput">
                                            <i class="bi bi-send"></i> 送信
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="p-3 text-center text-muted">
                            <p>このセッションタイプではWebUIは使用できません</p>
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="d-flex align-items-center justify-content-center h-100">
                    <div class="text-center text-muted">
                        <i class="bi bi-terminal" style="font-size: 4rem;"></i>
                        <p class="mt-3">左側からセッションを選択してください</p>
                    </div>
                </div>
            }
        </div>
    </div>
</div>


@code {
    private List<SessionInfo> sessions = new();
    private Guid? activeSessionId;
    private bool isAddingSession = false;
    private bool showCreateDialog = false;
    private Dictionary<Guid, IJSObjectReference> terminals = new();
    private ConPtySession? activeSession;
    
    // テキスト履歴機能
    private List<string> inputHistory = new();
    private int historyIndex = -1;
    private DotNetObjectReference<Root>? dotNetRef;
    private Toast? toast;
    private string inputText = "";
    private bool shouldPreventDefault = false;
    private Guid? editingMemoSessionId = null;
    private string tempMemoText = "";
    private bool showDevWindow = false;
    private bool showDevButton = false;
    private DevWindow? devWindow;
    private bool showSettingsDialog = false;
    private bool showSubSessionDialog = false;
    private string? subSessionParentSessionName = null;
    private Guid? subSessionParentSessionId = null;
    private string? subSessionParentSessionPath = null;
    private bool subSessionParentSessionIsGitRepository = true;
    private bool showSessionSettingsDialog = false;
    private Guid? settingsSessionId = null;
    
    // スナップショット設定
    private int _defaultSnapshotLines = 50;
    private int _recreateSnapshotLines = 100;
    
    // 処理状態管理用（セッションごと）
    private Dictionary<Guid, System.Threading.Timer> sessionProcessingTimers = new();

    protected override async Task OnInitializedAsync()
    {
        dotNetRef = DotNetObjectReference.Create(this);

        // 開発モード設定を読み込み
        showDevButton = Configuration.GetValue<bool>("DevelopmentMode:ShowDevButton", false);
        showDevWindow = Configuration.GetValue<bool>("DevelopmentMode:ShowDevWindowOnStartup", false);
        
        // スナップショット設定を読み込み
        _defaultSnapshotLines = Configuration.GetValue<int>("TerminalSettings:DefaultSnapshotLines", 50);
        _recreateSnapshotLines = Configuration.GetValue<int>("TerminalSettings:RecreateSnapshotLines", 100);
        
        // 通知権限をリクエスト（削除 - 設定モーダルに移動）
        // await NotificationService.RequestBrowserNotificationPermissionAsync();

        // テキスト履歴を読み込み
        await LoadInputHistoryAsync();
        
        // ローカルストレージからセッション情報を復元
        var savedSessions = await LocalStorageService.LoadSessionsAsync();
        var savedActiveId = await LocalStorageService.LoadActiveSessionIdAsync();

        // 保存されたセッション情報をSessionManagerに復元
        var restoredSessionIds = new HashSet<Guid>();
        foreach (var sessionInfo in savedSessions)
        {
            // 重複チェック（ホットリロード対策）
            var existingSession = SessionManager.GetSessionInfo(sessionInfo.SessionId);
            if (existingSession != null)
            {
                restoredSessionIds.Add(sessionInfo.SessionId);
                continue;
            }

            // セッションを再作成（ターミナルプロセスの起動）- 元のSessionIDを使用
            try
            {
                var newSession = await SessionManager.CreateSessionAsync(
                    sessionInfo.SessionId,
                    sessionInfo.FolderPath,
                    sessionInfo.DisplayName ?? "",
                    sessionInfo.TerminalType,
                    sessionInfo.Options);

                // メモ情報と親子関係を復元
                var createdSession = SessionManager.GetSessionInfo(newSession.SessionId);
                if (createdSession != null)
                {
                    if (!string.IsNullOrEmpty(sessionInfo.Memo))
                    {
                        createdSession.Memo = sessionInfo.Memo;
                    }
                    
                    // 親子関係を復元
                    if (sessionInfo.ParentSessionId.HasValue)
                    {
                        createdSession.ParentSessionId = sessionInfo.ParentSessionId;
                    }
                    
                    await SessionManager.SaveSessionInfoAsync(createdSession);
                }

                restoredSessionIds.Add(newSession.SessionId);
            }
            catch (Exception)
            {
                // Failed to restore session
            }
        }

        sessions = SessionManager.GetAllSessions().ToList();

        // 保存されたアクティブセッションがあれば選択
        if (savedActiveId != null && sessions.Any(s => s.SessionId == savedActiveId))
        {
            await SelectSession(savedActiveId.Value);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // キーボードショートカットを登録
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setupKeyboardShortcuts", dotNetRef);
            // 通知用のDotNetRefを設定
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setDotNetRef", dotNetRef);
        }
    }

    [JSInvokable]
    public async Task OnShortcutNewSession()
    {
        await AddSession();
    }
    
    [JSInvokable]
    public async Task OnNotificationClick(string sessionId)
    {
        if (Guid.TryParse(sessionId, out var guid))
        {
            await SelectSession(guid);
        }
    }

    private async Task AddSession()
    {
        showCreateDialog = true;
        await Task.CompletedTask; // 必要に応じて非同期処理を追加
    }
    
    private void ShowSettings()
    {
        showSettingsDialog = true;
    }
    
    private void ToggleDevWindow()
    {
        showDevWindow = !showDevWindow;
        if (showDevWindow && devWindow != null)
        {
            // DevWindowにターミナル辞書を渡す
            devWindow.SetTerminalsDict(terminals);
        }
    }

    private async Task OnSessionCreate(SessionCreateDialog.SessionCreateResult result)
    {
        showCreateDialog = false;
        isAddingSession = true;

        try
        {
            var sessionInfo = await SessionManager.CreateSessionAsync(
                result.FolderPath, 
                "", // セッション名は空（フォルダ名を使用）
                result.TerminalType, 
                result.Options);

            sessions = SessionManager.GetAllSessions().ToList();

            // ローカルストレージに保存
            await LocalStorageService.SaveSessionsAsync(sessions);

            StateHasChanged();

            await Task.Delay(TerminalConstants.DomUpdateDelay);
            await SelectSession(sessionInfo.SessionId);
        }
        catch (Exception ex)
        {
            toast?.ShowError($"セッション作成エラー: {ex.Message}");
        }
        finally
        {
            isAddingSession = false;
        }
    }

    private void OnDialogCancel()
    {
        showCreateDialog = false;
    }


    private async Task SelectSession(Guid sessionId)
    {
        Console.WriteLine($"[SelectSession] ★ 開始: {sessionId}");
        
        if (activeSessionId == sessionId)
        {
            Console.WriteLine($"[SelectSession] 既にアクティブなセッション: {sessionId}");
            return;
        }

        // 前のセッションの処理は継続させるため、キャンセルしない
        // セッションも常時接続状態を保つため、ターミナルも破棄しない

        // すべてのターミナルを非表示にする（JavaScriptで直接制御）
        Console.WriteLine($"[SelectSession] ターミナル非表示処理開始");
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalFunctions.hideAllTerminals");
            Console.WriteLine($"[SelectSession] ターミナル非表示処理完了");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SelectSession] ターミナル非表示処理エラー: {ex.Message}");
            Console.WriteLine($"[SelectSession] スタックトレース: {ex.StackTrace}");
            // エラーが発生しても処理を継続
        }

        // セッションをアクティブに
        Console.WriteLine($"[SelectSession] セッションアクティブ化開始: {sessionId}");
        await SessionManager.SetActiveSessionAsync(sessionId);
        activeSessionId = sessionId;
        Console.WriteLine($"[SelectSession] セッションアクティブ化完了: {sessionId}");
        
        // セッションを取得（初回は接続、2回目以降は既存のものを再利用）
        Console.WriteLine($"[SelectSession] セッション取得開始: {sessionId}");
        activeSession = await SessionManager.GetSessionAsync(sessionId);
        if (activeSession == null)
        {
            Console.WriteLine($"[SelectSession] ★★★ エラー: セッションが見つからない: {sessionId}");
            activeSessionId = null;
            return;
        }
        Console.WriteLine($"[SelectSession] セッション取得完了: {sessionId}");
        
        // 通知フラグをクリア
        Console.WriteLine($"[SelectSession] 通知フラグクリア処理開始");
        var selectedSession = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (selectedSession != null && selectedSession.HasNotificationPending)
        {
            selectedSession.HasNotificationPending = false;
            Console.WriteLine($"[SelectSession] 通知フラグをクリア: {sessionId}");
        }

        // アクティブセッション変更を即座にUIに反映
        Console.WriteLine($"[SelectSession] UI更新処理開始");
        StateHasChanged();
        Console.WriteLine($"[SelectSession] UI更新処理完了");

        // アクティブセッションIDをローカルストレージに保存
        Console.WriteLine($"[SelectSession] ローカルストレージ保存開始");
        await LocalStorageService.SaveActiveSessionIdAsync(sessionId);
        Console.WriteLine($"[SelectSession] ローカルストレージ保存完了");

        // ターミナルdivが存在するか確認し、表示する
        Console.WriteLine($"[SelectSession] ターミナルdiv存在確認開始");
        try
        {
            var divExists = await JSRuntime.InvokeAsync<bool>("terminalHubHelpers.checkElementExists", 
                $"terminal-{sessionId.ToString()}");
            Console.WriteLine($"[SelectSession] ターミナルdiv存在確認結果: {divExists}");

            if (divExists)
            {
                Console.WriteLine($"[SelectSession] ターミナル表示処理開始");
                await JSRuntime.InvokeVoidAsync("terminalFunctions.showTerminal", sessionId.ToString());
                Console.WriteLine($"[SelectSession] ターミナル表示処理完了");
            }
            else
            {
                Console.WriteLine($"[SelectSession] ★★★ 警告: ターミナルdivが存在しない: terminal-{sessionId}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SelectSession] ターミナルdiv処理エラー: {ex.Message}");
        }

        // ターミナルを初期化
        Console.WriteLine($"[SelectSession] ターミナル初期化開始");
        await InitializeTerminal(sessionId);
        Console.WriteLine($"[SelectSession] ターミナル初期化完了");

        // アクティブターミナルのリサイズを強制的に実行
        Console.WriteLine($"[SelectSession] リサイズ処理開始");
        try
        {
            if (terminals.TryGetValue(sessionId, out var terminal))
            {
                Console.WriteLine($"[SelectSession] ターミナルが見つかりました、リサイズ実行");
                await terminal.InvokeVoidAsync("resize");
                Console.WriteLine($"[SelectSession] リサイズ完了");
            }
            else
            {
                Console.WriteLine($"[SelectSession] ★★★ 警告: ターミナルが辞書に存在しない");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SelectSession] リサイズエラー: {ex.Message}");
        }

        // セッション選択時はバッファから内容を取得して表示
        if (selectedSession?.ConPtyBuffer != null && terminals.TryGetValue(sessionId, out var selectedTerminal))
        {
            await Task.Delay(100); // ターミナル初期化完了を待つ
            
            // バッファの内容をターミナルに書き込む（初回表示）
            var bufferedOutput = selectedSession.ConPtyBuffer.GetBufferedOutput();
            if (!string.IsNullOrEmpty(bufferedOutput))
            {
                try
                {
                    // ターミナルをクリアしてからバッファ内容を表示
                    await selectedTerminal.InvokeVoidAsync("clear");
                    await selectedTerminal.InvokeVoidAsync("write", bufferedOutput);
                }
                catch { }
            }
        }

        // ConPtyWithBufferのイベントハンドラーを設定
        if (selectedSession?.ConPtyBuffer != null)
        {
            // ConPtyWithBufferイベントハンドラーを設定
            
            // 既存のイベントハンドラーをクリア
            selectedSession.ConPtyBuffer.ClearEventHandlers();
            
            // セッション切り替え直後のフラグ
            bool isInitialData = true;
            var initialDataTimer = new System.Threading.Timer(async _ =>
            {
                if (isInitialData)
                {
                    isInitialData = false;
                    // 再描画データ受信完了と判断して最下部へスクロール
                    await InvokeAsync(async () =>
                    {
                        try
                        {
                            await JSRuntime.InvokeVoidAsync("terminalFunctions.scrollToBottom", sessionId.ToString());
                            // 再描画完了後のスクロール実行
                        }
                        catch { }
                    });
                }
            }, null, 500, Timeout.Infinite); // 500ms後に実行
            
            // データ受信イベントハンドラー
            selectedSession.ConPtyBuffer.DataReceived += async (data) =>
            {
                try
                {
                    await ProcessReceivedData(sessionId, data);
                }
                catch (Exception ex)
                {
                    // [DataReceived] エラー処理
                }
            };
            
            // 切断イベントハンドラー
            selectedSession.ConPtyBuffer.Disconnected += () =>
            {
                Console.WriteLine($"[CreateSession] セッション切断検出: {sessionId}");
                initialDataTimer?.Dispose();
                
                // UI更新のためInvokeAsyncを使用
                _ = InvokeAsync(async () =>
                {
                    // セッションがまだ存在するか確認（再起動中の場合は削除しない）
                    var sessionStillExists = sessions.Any(s => s.SessionId == sessionId);
                    if (sessionStillExists)
                    {
                        Console.WriteLine($"[CreateSession] セッションを削除: {sessionId}");
                        await RemoveSession(sessionId);
                        toast?.ShowInfo("セッションが終了しました");
                    }
                    else
                    {
                        Console.WriteLine($"[CreateSession] セッションは既に削除済み: {sessionId}");
                    }
                });
            };
        }
        else
        {
            // ConPtyBufferが利用不可
        }

        // ターミナルを最下段にスクロール
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalFunctions.scrollToBottom", sessionId.ToString());
        }
        catch (Exception)
        {
            // エラーは無視
        }

        // テキストエリアにフォーカス
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.focusTextArea");
        }
        catch (Exception)
        {
            // エラーは無視
        }
    }

    private async Task InitializeTerminal(Guid sessionId)
    {
        var terminalId = $"terminal-{sessionId.ToString()}";
        Console.WriteLine($"[InitializeTerminal] ★ 開始: terminalId={terminalId}");

        // 既存のターミナルがあればそれを使用、なければ新規作成
        if (!terminals.ContainsKey(sessionId))
        {
            Console.WriteLine($"[InitializeTerminal] 新規ターミナル作成開始");
            // JavaScript側の既存ターミナルも削除（初回作成時のみ）
            try
            {
                await JSRuntime.InvokeVoidAsync("terminalFunctions.cleanupTerminal", sessionId.ToString());
                Console.WriteLine($"[InitializeTerminal] 既存ターミナルクリーンアップ完了");
            }
            catch (Exception ex) 
            { 
                Console.WriteLine($"[InitializeTerminal] クリーンアップエラー: {ex.Message}");
            }

            try
            {
                Console.WriteLine($"[InitializeTerminal] JavaScript側ターミナル作成開始");
                var terminal = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "terminalFunctions.createMultiSessionTerminal", 
                    terminalId, 
                    sessionId.ToString(), 
                    dotNetRef);

                terminals[sessionId] = terminal;
                Console.WriteLine($"[InitializeTerminal] ターミナル作成完了、辞書に登録");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[InitializeTerminal] ★★★ ターミナル作成エラー: {ex.Message}");
            }
        }
        else
        {
            Console.WriteLine($"[InitializeTerminal] 既存ターミナルを再利用");
        }
        Console.WriteLine($"[InitializeTerminal] ★ 完了");
    }

    private async Task ProcessReceivedData(Guid sessionId, string data)
    {
        try
        {
            var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
            if (sessionInfo != null)
            {
                // Claude Codeの場合、"No conversation found to continue"エラーをチェック
                if (sessionInfo.TerminalType == TerminalType.ClaudeCode && 
                    data.Contains("No conversation found to continue") &&
                    sessionInfo.Options.ContainsKey("continue") &&
                    !sessionInfo.HasContinueErrorOccurred)
                {
                    Console.WriteLine($"[ProcessReceivedData] Claude Code --continue エラー検出: {sessionId}");
                    
                    // フラグを設定して重複送信を防ぐ
                    sessionInfo.HasContinueErrorOccurred = true;
                    
                    // セッション再起動のコマンドを送信
                    _ = InvokeAsync(async () =>
                    {
                        await RestartSessionWithoutContinue(sessionId);
                    });
                    return;
                }

                // 対応するターミナルに出力（アクティブでなくても）
                if (terminals.TryGetValue(sessionId, out var terminal))
                {
                    await terminal.InvokeVoidAsync("write", data);
                    
                    // 出力解析の実行
                    _ = InvokeAsync(() => AnalyzeOutput(data, sessionId, sessionInfo.TerminalType));
                }
                // 非アクティブセッションの場合はバッファリングはConPtyWithBufferが担当
                // 特別な処理は不要
            }
        }
        catch (Exception ex)
        {
            // ProcessReceivedData error
        }
    }


    private void StartEditingMemo(Guid sessionId, string currentMemo)
    {
        editingMemoSessionId = sessionId;
        tempMemoText = currentMemo ?? "";
        StateHasChanged();
    }

    private async Task SaveMemo(Guid sessionId)
    {
        if (editingMemoSessionId == sessionId)
        {
            await UpdateSessionMemo(sessionId, tempMemoText);
            editingMemoSessionId = null;
            tempMemoText = "";
            StateHasChanged();
        }
    }

    private async Task HandleMemoKeyDown(KeyboardEventArgs e, Guid sessionId)
    {
        if (e.Key == "Enter")
        {
            await SaveMemo(sessionId);
        }
        else if (e.Key == "Escape")
        {
            editingMemoSessionId = null;
            tempMemoText = "";
            StateHasChanged();
        }
    }

    private async Task UpdateSessionMemo(Guid sessionId, string memo)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            session.Memo = memo;
            // ローカルストレージを更新
            await LocalStorageService.SaveSessionsAsync(sessions);
        }
    }

    private async Task RemoveSession(Guid sessionId)
    {
        Console.WriteLine($"[RemoveSession] ★ セッション削除開始: {sessionId}");
        
        // ConPtyWithBufferのクリーンアップ
        var sessionToRemove = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionToRemove?.ConPtyBuffer != null)
        {
            sessionToRemove.ConPtyBuffer.Dispose();
            Console.WriteLine($"[RemoveSession] ConPtyBufferを破棄");
        }
        
        // セッションのタイマーを停止
        StopSessionTimer(sessionId);
        Console.WriteLine($"[RemoveSession] タイマー停止");

        // 対応するターミナルをクリーンアップ
        if (terminals.TryGetValue(sessionId, out var terminal))
        {
            Console.WriteLine($"[RemoveSession] ターミナル破棄開始");
            await terminal.DisposeAsync();
            terminals.Remove(sessionId);
            Console.WriteLine($"[RemoveSession] ターミナル辞書から削除");
        }
        
        // JavaScript側のクリーンアップも明示的に実行
        try
        {
            Console.WriteLine($"[RemoveSession] JavaScript側クリーンアップ開始");
            await JSRuntime.InvokeVoidAsync("terminalFunctions.cleanupTerminal", sessionId.ToString());
            Console.WriteLine($"[RemoveSession] JavaScript側クリーンアップ完了");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[RemoveSession] JavaScript側クリーンアップエラー: {ex.Message}");
        }

        await SessionManager.RemoveSessionAsync(sessionId);
        sessions = SessionManager.GetAllSessions().ToList();
        Console.WriteLine($"[RemoveSession] セッション削除後の残りセッション数: {sessions.Count}");

        // ローカルストレージを更新
        await LocalStorageService.SaveSessionsAsync(sessions);

        if (activeSessionId == sessionId)
        {
            activeSessionId = null;
            activeSession = null;

            // セッション削除を即座にUIに反映
            StateHasChanged();

            await LocalStorageService.SaveActiveSessionIdAsync(null);

            // 他のセッションがあれば最初のものを選択
            if (sessions.Any())
            {
                await SelectSession(sessions.First().SessionId);
            }
        }
        else
        {
            // 削除されたセッションがアクティブでない場合もUIを更新
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task SendInput(string sessionId, string data)
    {
        var guid = Guid.Parse(sessionId);
        if (activeSession != null && guid == activeSessionId)
        {
            await activeSession.WriteAsync(data);
        }
    }

    [JSInvokable]
    public async Task OnTerminalSizeChanged(string sessionId, int cols, int rows)
    {
        var guid = Guid.Parse(sessionId);
        
        // アクティブセッションでない場合は何もしない
        if (guid != activeSessionId) return;
        
        // セッション情報を取得
        var selectedSession = sessions.FirstOrDefault(s => s.SessionId == guid);
        if (selectedSession?.ConPtyBuffer == null) return;
        
        // アクティブセッションのリサイズ処理
        // 画面をクリア
        if (terminals.TryGetValue(guid, out var terminal))
        {
            try
            {
                await terminal.InvokeVoidAsync("clear");
            }
            catch { }
        }
        
        // バッファをクリア（リサイズ前に必須）
        selectedSession.ConPtyBuffer.ClearBuffer();
        
        // ConPtyにリサイズを通知（activeSessionが存在する場合のみ）
        if (activeSession != null)
        {
            activeSession.Resize(cols, rows);
        }
        
        // ConPtyWithBufferもリサイズを通知
        selectedSession.ConPtyBuffer.Resize(cols, rows);
        
        // リサイズ後、ConPTYが全バッファを送信してくるので
        // それを新しいバッファに蓄積していく
    }

    private async Task DestroyTerminal(Guid sessionId, bool showAlert = true)
    {
        // Console.WriteLine($"[DestroyTerminal] セッション {sessionId} のターミナルを破棄");

        try
        {
            // JavaScript側のターミナルを破棄
            await JSRuntime.InvokeVoidAsync("terminalFunctions.destroyTerminal", sessionId.ToString());

            // C#側のターミナル参照を削除
            if (terminals.TryGetValue(sessionId, out var terminal))
            {
                await terminal.DisposeAsync();
                terminals.Remove(sessionId);
            }


            if (showAlert)
            {
                toast?.ShowSuccess("ターミナルを破棄しました");
            }
        }
        catch (Exception ex)
        {
            // Console.WriteLine($"[DestroyTerminal] エラー: {ex.Message}");
            if (showAlert)
            {
                toast?.ShowError($"ターミナル破棄エラー: {ex.Message}");
            }
        }
    }

    private async Task RecreateTerminal(Guid sessionId)
    {
        // Console.WriteLine($"[RecreateTerminal] セッション {sessionId} のターミナルを再作成");

        try
        {
            // セッションがアクティブな場合のみ再作成
            if (activeSessionId == sessionId)
            {
                // 既存のターミナルを破棄（アラートなし）
                await DestroyTerminal(sessionId, false);

                // DOM更新と読み取りタスクの完全な終了を待つ
                await Task.Delay(TerminalConstants.SessionCreationDelay);

                // ターミナルdivの表示状態を確実に設定
                await JSRuntime.InvokeVoidAsync("terminalFunctions.ensureTerminalVisible", sessionId.ToString());

                // 新しいターミナルを初期化
                await InitializeTerminal(sessionId);

                // ConPTYから自動的に画面状態が送信されるため、スナップショット送信は不要
                var selectedSessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
                if (selectedSessionInfo?.ConPtyBuffer != null && terminals.ContainsKey(sessionId))
                {
                    await Task.Delay(100); // ターミナル初期化完了を待つ
                    
                    // スナップショット送信を無効化（ConPTYが画面状態を自動送信）
                    // ConPTYによる画面状態の自動復元に依存
                    
                    // データ受信イベントハンドラー
                    selectedSessionInfo.ConPtyBuffer.DataReceived += async (data) =>
                    {
                        try
                        {
                            await ProcessReceivedData(sessionId, data);
                        }
                        catch (Exception ex)
                        {
                            // [DataReceived] エラー処理
                        }
                    };
                    
                    // 切断イベントハンドラー
                    selectedSessionInfo.ConPtyBuffer.Disconnected += () =>
                    {
                        Console.WriteLine($"[InitializeAndSwitchToSession] セッション切断検出: {sessionId}");
                        
                        // UI更新のためInvokeAsyncを使用
                        _ = InvokeAsync(async () =>
                        {
                            // セッションがまだ存在するか確認（再起動中の場合は削除しない）
                            var sessionStillExists = sessions.Any(s => s.SessionId == sessionId);
                            if (sessionStillExists)
                            {
                                Console.WriteLine($"[InitializeAndSwitchToSession] セッションを削除: {sessionId}");
                                await RemoveSession(sessionId);
                                toast?.ShowInfo("セッションが終了しました");
                            }
                            else
                            {
                                Console.WriteLine($"[InitializeAndSwitchToSession] セッションは既に削除済み: {sessionId}");
                            }
                        });
                    };

                    // ターミナルに初期プロンプトを送信して接続を確認
                    if (activeSession != null)
                    {
                        // Enterキーを送信してプロンプトを表示
                        await activeSession.WriteAsync("\r\n");
                        // Console.WriteLine($"[RecreateTerminal] プロンプト送信完了");
                    }
                }

                toast?.ShowSuccess("ターミナルを再作成しました");
            }
            else
            {
                toast?.ShowWarning("このセッションを選択してからターミナルを再作成してください");
            }
        }
        catch (Exception ex)
        {
            // Console.WriteLine($"[RecreateTerminal] エラー: {ex.Message}");
            toast?.ShowError($"ターミナル再作成エラー: {ex.Message}");
        }
    }



    private void AnalyzeOutput(string data, Guid sessionId, TerminalType terminalType)
    {
        try
        {
            // ターミナルタイプに応じた解析器を取得
            var analyzer = AnalyzerFactory.GetAnalyzer(terminalType);
            if (analyzer == null)
            {
                // 解析器がない場合は何もしない
                return;
            }

            // 解析を実行
            if (analyzer.TryAnalyze(data, out var result))
            {
                var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
                if (session == null) return;

                if (result.IsInterrupted)
                {
                    // 処理が中断された
                    UpdateSessionProcessingStatus(sessionId, null);
                }
                else if (result.IsProcessing)
                {
                    // ユーザー入力待ち状態をセッションに設定
                    session.IsWaitingForUserInput = result.IsWaitingForUser;
                    
                    // 処理中
                    if (result.ElapsedSeconds.HasValue)
                    {
                        // 秒数の変化をチェック
                        var secondsStr = result.ElapsedSeconds.Value.ToString();
                        if (session.LastProcessingSeconds == secondsStr)
                        {
                            // 秒数が変わらない場合はタイマーのリセットのみ
                            session.LastProcessingUpdateTime = DateTime.Now;
                            ResetSessionTimer(sessionId);
                            return;
                        }
                        
                        session.LastProcessingSeconds = secondsStr;
                        
                        // GeminiCLIの場合はステータステキストも含める
                        if (!string.IsNullOrEmpty(result.StatusText))
                        {
                            UpdateSessionProcessingStatus(sessionId, result.StatusText, result.ElapsedSeconds.Value, 
                                result.Tokens ?? "", result.Direction ?? "");
                        }
                        else
                        {
                            UpdateSessionProcessingStatus(sessionId, result.ElapsedSeconds.Value, 
                                result.Tokens ?? "", result.Direction ?? "");
                        }
                    }
                    else if (!string.IsNullOrEmpty(result.StatusText))
                    {
                        // ステータステキストのみの更新
                        UpdateSessionProcessingStatus(sessionId, result.StatusText);
                    }
                }
                else
                {
                    // 処理完了
                    UpdateSessionProcessingStatus(sessionId, null);
                }
            }
        }
        catch (Exception ex)
        {
            // Output Analysis Error
        }
    }

    private void UpdateSessionProcessingStatus(Guid sessionId, string? statusText)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            // Console.WriteLine($"[UI Update] セッション {activeSessionId} の処理状態を更新: {statusText ?? "null"}");
            
            session.ProcessingStatus = statusText;
            if (statusText != null)
            {
                session.ProcessingStartTime = DateTime.Now;
                session.LastProcessingUpdateTime = DateTime.Now;
                
                // セッションごとのタイマーをリセット
                ResetSessionTimer(sessionId);
            }
            else
            {
                //Console.WriteLine($"[Notification Debug] UpdateSessionProcessingStatus - 処理完了を検出");
                //Console.WriteLine($"[Notification Debug] ProcessingElapsedSeconds: {session.ProcessingElapsedSeconds}");
                
                // 処理完了時の通知
                var processingElapsedSeconds = session.ProcessingElapsedSeconds;
                if (processingElapsedSeconds.HasValue)
                {
                    //Console.WriteLine($"[Notification Debug] 通知サービスを呼び出し中 - {processingElapsedSeconds.Value}秒");
                    
                    // 通知フラグを設定（アクティブでない場合のみ）
                    if (activeSessionId != session.SessionId)
                    {
                        session.HasNotificationPending = true;
                        //Console.WriteLine($"[Notification Debug] セッション {session.SessionId} に通知フラグを設定");
                    }
                    
                    // セッション情報をコピー（非同期処理で使用するため）
                    var sessionCopy = new SessionInfo
                    {
                        SessionId = session.SessionId,
                        DisplayName = session.DisplayName,
                        FolderPath = session.FolderPath,
                        FolderName = session.FolderName,
                        CreatedAt = session.CreatedAt,
                        LastAccessedAt = session.LastAccessedAt,
                        IsActive = session.IsActive,
                        TerminalType = session.TerminalType,
                        Options = session.Options,
                        Memo = session.Memo
                    };
                    var elapsedSecondsCopy = processingElapsedSeconds.Value;
                    
                    var notificationTask = Task.Run(async () => 
                    {
                        try
                        {
                            //Console.WriteLine($"[Notification Debug] NotifyProcessingCompleteAsync呼び出し開始");
                            //Console.WriteLine($"[Notification Debug] SessionCopy - Id: {sessionCopy.SessionId}, FolderPath: {sessionCopy.FolderPath}");
                            await NotificationService.NotifyProcessingCompleteAsync(sessionCopy, elapsedSecondsCopy);
                            //Console.WriteLine($"[Notification Debug] NotifyProcessingCompleteAsync呼び出し完了");
                        }
                        catch (Exception ex)
                        {
                            // Notification error
                            // Stack trace
                        }
                    });
                }
                else
                {
                    //Console.WriteLine($"[Notification Debug] ProcessingElapsedSecondsがnullのため通知をスキップ");
                }
                
                session.ProcessingStartTime = null;
                session.ProcessingElapsedSeconds = null;
                session.ProcessingTokens = null;
                session.ProcessingDirection = null;
                session.LastProcessingUpdateTime = null;
                session.LastProcessingSeconds = null;
                session.IsWaitingForUserInput = false;
                
                // セッションのタイマーを停止
                StopSessionTimer(sessionId);
            }
            
            // UIスレッドで強制的に更新
            try
            {
                InvokeAsync(StateHasChanged);
                //Console.WriteLine("[UI Update] StateHasChanged実行完了");
            }
            catch (Exception ex)
            {
                // StateHasChanged error
            }
        }
        else
        {
            // Active session not found
        }
    }
    
    private void UpdateSessionProcessingStatus(Guid sessionId, int elapsedSeconds, string tokens, string direction)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            // Console.WriteLine($"[UI Update] セッション {activeSessionId} の処理状態を更新: {elapsedSeconds}秒, {tokens}トークン, {direction}");
            
            session.ProcessingElapsedSeconds = elapsedSeconds;
            session.ProcessingTokens = tokens;
            session.ProcessingDirection = direction;
            
            if (session.ProcessingStartTime == null)
            {
                session.ProcessingStartTime = DateTime.Now;
            }
            
            session.LastProcessingUpdateTime = DateTime.Now;
            
            // セッションごとのタイマーをリセット
            ResetSessionTimer(sessionId);
            
            // UIスレッドで強制的に更新
            try
            {
                InvokeAsync(StateHasChanged);
                //Console.WriteLine("[UI Update] StateHasChanged実行完了");
            }
            catch (Exception ex)
            {
                // StateHasChanged error
            }
        }
        else
        {
            // Active session not found
        }
    }
    
    private void UpdateSessionProcessingStatus(Guid sessionId, string statusText, int elapsedSeconds, string tokens, string direction)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            session.ProcessingStatus = statusText;
            session.ProcessingElapsedSeconds = elapsedSeconds;
            session.ProcessingTokens = tokens;
            session.ProcessingDirection = direction;
            
            if (session.ProcessingStartTime == null)
            {
                session.ProcessingStartTime = DateTime.Now;
            }
            
            session.LastProcessingUpdateTime = DateTime.Now;
            
            // セッションごとのタイマーをリセット
            ResetSessionTimer(sessionId);
            
            // UIスレッドで強制的に更新
            try
            {
                InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                // StateHasChanged error
            }
        }
        else
        {
            // Session not found
        }
    }

    private void ResetSessionTimer(Guid sessionId)
    {
        // 既存のタイマーを停止
        StopSessionTimer(sessionId);
        
        // 新しいタイマーを作成
        var timer = new System.Threading.Timer(
            (state) => CheckSessionTimeout(sessionId),
            null,
            TimeSpan.FromSeconds(5),
            Timeout.InfiniteTimeSpan
        );
        
        sessionProcessingTimers[sessionId] = timer;
    }
    
    private void StopSessionTimer(Guid sessionId)
    {
        if (sessionProcessingTimers.TryGetValue(sessionId, out var timer))
        {
            timer?.Dispose();
            sessionProcessingTimers.Remove(sessionId);
        }
    }
    
    private void CheckSessionTimeout(Guid sessionId)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            var lastUpdateTime = session.LastProcessingUpdateTime;
            if (!lastUpdateTime.HasValue)
            {
                return;
            }
            
            // ユーザー入力待ち状態の場合はタイムアウトしない
            if (session.IsWaitingForUserInput)
            {
                // タイマーを再設定して後でまた確認
                ResetSessionTimer(sessionId);
                return;
            }
            
            var elapsedTime = (DateTime.Now - lastUpdateTime.Value).TotalSeconds;
            
            if (elapsedTime >= 5)
            {
                // Console.WriteLine($"[Claude Code Status] セッション {sessionId} で5秒間更新がないため処理終了と判定");
                InvokeAsync(() => UpdateSessionProcessingStatus(sessionId, null));
            }
        }
    }

    private async Task SendInput()
    {
        if (activeSession == null)
            return;

        var currentSession = sessions.FirstOrDefault(s => s.SessionId == activeSessionId);
        if (currentSession == null)
            return;

        // テキストがある場合は送信
        if (!string.IsNullOrWhiteSpace(inputText))
        {
            // テキスト履歴に追加
            AddToInputHistory(inputText);
            
            await activeSession.WriteAsync(inputText);
            
            // テキスト送信後、Enter送信前に0.2秒待機
            await Task.Delay(200);
        }
        
        // Enterキーを送信（空の場合でも送信）
        await SendEnterKeyDirect();
        
        // 入力フィールドをクリア
        inputText = "";
    }

    private async Task OnTextAreaKeyDown(KeyboardEventArgs e)
    {
        // Enter で送信（Shiftキーが押されていない場合）
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            shouldPreventDefault = true;
            await SendInput();
            shouldPreventDefault = false;
        }
        // 履歴機能: 上矢印で前の履歴、下矢印で次の履歴
        else if (e.Key == "ArrowUp" && e.CtrlKey)
        {
            shouldPreventDefault = true;
            NavigateHistory(-1);
        }
        else if (e.Key == "ArrowDown" && e.CtrlKey)
        {
            shouldPreventDefault = true;
            NavigateHistory(1);
        }
        else
        {
            shouldPreventDefault = false;
        }
        // Shift+Enter は通常の改行動作（何もしない）
    }

    private string GetPlaceholderText(TerminalType terminalType)
    {
        return terminalType == TerminalType.ClaudeCode 
            ? "Claude Codeへのメッセージを入力..." 
            : "Gemini CLIへのメッセージを入力...";
    }

    private bool isEscapePressed = false;
    private bool isModeSwitchPressed = false;
    private bool isCtrlCPressed = false;

    private async Task SendCtrlC()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isCtrlCPressed = true;

        // Ctrl+Cを送信（\x03 はCtrl+Cの制御文字）
        await activeSession.WriteAsync("\x03");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isCtrlCPressed = false;
    }

    private async Task SendEscape()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isEscapePressed = true;

        // Escキーを送信（\x1B はESCのエスケープシーケンス）
        await activeSession.WriteAsync("\x1B");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isEscapePressed = false;
    }

    private async Task SendModeSwitch()
    {
        if (activeSession == null)
            return;

        // ボタンの押下状態を表示
        isModeSwitchPressed = true;

        // Alt+M を送信（\x1B はESC、m はM）
        await activeSession.WriteAsync("\x1Bm");

        // 押下状態を解除
        await Task.Delay(TerminalConstants.ButtonPressAnimationDelay);
        isModeSwitchPressed = false;
    }


    private void ShowWorktreeDialog(Guid sessionId)
    {
        var session = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session != null)
        {
            // Git管理されていない場合でも、サブセッションダイアログは表示する
            // （同じフォルダで開くオプションは利用可能）
            subSessionParentSessionId = sessionId;
            subSessionParentSessionName = session.GetDisplayName();
            subSessionParentSessionPath = session.FolderPath;
            subSessionParentSessionIsGitRepository = session.IsGitRepository;
            showSubSessionDialog = true;
        }
    }

    private async Task OnSubSessionOperation(SubSessionDialog.SubSessionResult result)
    {
        if (!subSessionParentSessionId.HasValue)
        {
            showSubSessionDialog = false;
            return;
        }

        try
        {
            SessionInfo? newSession = null;
            
            switch (result.OperationType)
            {
                case SubSessionDialog.SubSessionType.CreateNew:
                    // 新規Worktree作成
                    if (result.UseExistingBranch)
                    {
                        // 既存ブランチでWorktree作成
                        newSession = await SessionManager.CreateWorktreeSessionWithExistingBranchAsync(
                            subSessionParentSessionId.Value, result.BranchName, result.TerminalType, result.Options);
                    }
                    else
                    {
                        // 新規ブランチでWorktree作成
                        newSession = await SessionManager.CreateWorktreeSessionAsync(
                            subSessionParentSessionId.Value, result.BranchName, result.TerminalType, result.Options);
                    }
                    break;
                    
                case SubSessionDialog.SubSessionType.AddExisting:
                    // 既存Worktree追加
                    if (!string.IsNullOrEmpty(result.WorktreePath))
                    {
                        newSession = await AddExistingWorktreeSession(subSessionParentSessionId.Value, result.WorktreePath, result.BranchName, result.TerminalType, result.Options);
                    }
                    break;
                    
                case SubSessionDialog.SubSessionType.SamePath:
                    // 同じフォルダでセッション作成
                    if (!string.IsNullOrEmpty(subSessionParentSessionPath))
                    {
                        newSession = await SessionManager.CreateSamePathSessionAsync(
                            subSessionParentSessionId.Value, subSessionParentSessionPath, result.TerminalType, result.Options);
                    }
                    break;
                    
                case SubSessionDialog.SubSessionType.NewFolder:
                    // 新しいフォルダでセッション作成
                    if (!string.IsNullOrEmpty(result.WorktreePath))
                    {
                        newSession = await CreateNewFolderSession(
                            subSessionParentSessionId.Value, result.WorktreePath, result.TerminalType, result.Options);
                    }
                    break;
            }
            
            if (newSession != null)
            {
                // セッション一覧を更新
                sessions = SessionManager.GetAllSessions().ToList();
                
                // ローカルストレージに保存
                await LocalStorageService.SaveSessionsAsync(sessions);
                
                // 新しいセッションを選択
                await SelectSession(newSession.SessionId);
                
                string successMessage = result.OperationType switch
                {
                    SubSessionDialog.SubSessionType.CreateNew => 
                        $"Worktree '{result.BranchName}' を作成しました",
                    SubSessionDialog.SubSessionType.AddExisting => 
                        $"既存のWorktree '{result.BranchName}' を追加しました",
                    SubSessionDialog.SubSessionType.SamePath => 
                        $"新しい{GetSessionTypeName(result.TerminalType)}セッションを作成しました",
                    SubSessionDialog.SubSessionType.NewFolder => 
                        $"新しいフォルダ '{result.WorktreePath}' でセッションを作成しました",
                    _ => "セッションを作成しました"
                };
                
                toast?.ShowSuccess(successMessage);
            }
            else
            {
                toast?.ShowError("セッション作成に失敗しました");
            }
        }
        catch (Exception ex)
        {
            toast?.ShowError($"セッション作成エラー: {ex.Message}");
        }
        finally
        {
            showSubSessionDialog = false;
            subSessionParentSessionId = null;
            subSessionParentSessionName = null;
            subSessionParentSessionPath = null;
            subSessionParentSessionIsGitRepository = true;
        }
    }
    
    private string GetSessionTypeName(TerminalType terminalType)
    {
        return terminalType switch
        {
            TerminalType.Terminal => "ターミナル",
            TerminalType.ClaudeCode => "Claude Code",
            TerminalType.GeminiCLI => "Gemini CLI",
            _ => "セッション"
        };
    }
    
    private async Task<SessionInfo?> AddExistingWorktreeSession(Guid parentSessionId, string worktreePath, string branchName, TerminalType terminalType, Dictionary<string, string> options)
    {
        // 親セッション情報を取得
        var parentSession = SessionManager.GetSessionInfo(parentSessionId);
        if (parentSession == null)
        {
            // Parent session not found
            return null;
        }
            
        // 既存のWorktreeをセッションとして追加（統一された表示名を使用）
        var sessionInfo = await SessionManager.CreateSessionAsync(
            worktreePath,
            $"{parentSession.DisplayName} ({branchName})",
            terminalType,
            options
        );
        
        // 親子関係を設定
        if (sessionInfo != null)
        {
            sessionInfo.ParentSessionId = parentSessionId;
            await SessionManager.SaveSessionInfoAsync(sessionInfo);
        }
        
        return sessionInfo;
    }
    
    private async Task<SessionInfo?> CreateNewFolderSession(Guid parentSessionId, string folderPath, TerminalType terminalType, Dictionary<string, string> options)
    {
        try
        {
            // 親セッション情報を取得
            var parentSession = SessionManager.GetSessionInfo(parentSessionId);
            if (parentSession == null)
            {
                // Parent session not found
                return null;
            }
                
            // フォルダが存在しない場合は作成
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
            }
            
            // 新しいフォルダでセッション作成（統一された表示名を使用）
            var sessionInfo = await SessionManager.CreateSessionAsync(
                folderPath,
                $"{parentSession.DisplayName} ({Path.GetFileName(folderPath)})",
                terminalType,
                options
            );
            
            // 親子関係を設定
            if (sessionInfo != null)
            {
                sessionInfo.ParentSessionId = parentSessionId;
                await SessionManager.SaveSessionInfoAsync(sessionInfo);
            }
            
            return sessionInfo;
        }
        catch (Exception ex)
        {
            // CreateNewFolderSession error
            return null;
        }
    }


    private async Task SendEnterKeyDirect()
    {
        if (activeSession == null)
            return;

        // 様々なEnterキーのパターンを試す
        // Windows環境では通常 \r\n だが、ターミナルによって異なる場合がある
        await activeSession.WriteAsync("\r");
    }

    
    // テキスト履歴関連メソッド
    private void AddToInputHistory(string text)
    {
        // 空白やnullは履歴に追加しない
        if (string.IsNullOrWhiteSpace(text))
            return;
            
        // 同じテキストが連続する場合は追加しない
        if (inputHistory.Count > 0 && inputHistory[inputHistory.Count - 1] == text)
            return;
            
        inputHistory.Add(text);
        
        // 履歴の最大数を制限（100件）
        if (inputHistory.Count > 100)
        {
            inputHistory.RemoveAt(0);
        }
        
        // 履歴インデックスをリセット
        historyIndex = -1;
    }
    
    private void NavigateHistory(int direction)
    {
        if (inputHistory.Count == 0)
            return;
            
        // 初回の履歴操作時
        if (historyIndex == -1)
        {
            if (direction < 0) // 上矢印（古い履歴へ）
            {
                historyIndex = inputHistory.Count - 1;
                inputText = inputHistory[historyIndex];
            }
            return;
        }
        
        // 履歴を移動
        var newIndex = historyIndex + direction;
        
        if (newIndex >= 0 && newIndex < inputHistory.Count)
        {
            historyIndex = newIndex;
            inputText = inputHistory[historyIndex];
        }
        else if (newIndex < 0)
        {
            // 最古の履歴より前に行こうとした場合
            historyIndex = 0;
            inputText = inputHistory[historyIndex];
        }
        else if (newIndex >= inputHistory.Count)
        {
            // 最新の履歴より後に行こうとした場合は空にする
            historyIndex = -1;
            inputText = "";
        }
    }
    
    private async Task SaveInputHistoryAsync()
    {
        try
        {
            await LocalStorageService.SetAsync("inputHistory", inputHistory);
        }
        catch (Exception ex)
        {
            // History save error
        }
    }
    
    private async Task LoadInputHistoryAsync()
    {
        try
        {
            var savedHistory = await LocalStorageService.GetAsync<List<string>>("inputHistory");
            if (savedHistory != null)
            {
                inputHistory = savedHistory;
                historyIndex = -1;
            }
        }
        catch (Exception ex)
        {
            // History load error
        }
    }

    private void ShowSessionSettingsDialog(Guid sessionId)
    {
        settingsSessionId = sessionId;
        showSessionSettingsDialog = true;
    }

    private async Task OnSessionSettingsSaved()
    {
        showSessionSettingsDialog = false;
        // セッション一覧を更新
        sessions = SessionManager.GetAllSessions().ToList();
        await LocalStorageService.SaveSessionsAsync(sessions);
        
        // セッションが再起動された場合、ターミナルコンポーネントも再読み込み
        if (settingsSessionId.HasValue)
        {
            var sessionId = settingsSessionId.Value;
            Console.WriteLine($"[OnSessionSettingsSaved] セッション設定保存後の処理開始: {sessionId}");
            
            // ターミナルをクリーンアップして再作成
            if (terminals.ContainsKey(sessionId))
            {
                Console.WriteLine($"[OnSessionSettingsSaved] 既存ターミナルをクリーンアップ");
                try
                {
                    var terminal = terminals[sessionId];
                    await terminal.DisposeAsync();
                }
                catch (Exception ex) 
                { 
                    Console.WriteLine($"[OnSessionSettingsSaved] ターミナル破棄エラー: {ex.Message}");
                }
                
                try
                {
                    await JSRuntime.InvokeVoidAsync("terminalFunctions.cleanupTerminal", sessionId.ToString());
                }
                catch (Exception ex) 
                { 
                    Console.WriteLine($"[OnSessionSettingsSaved] JavaScript側クリーンアップエラー: {ex.Message}");
                }
                terminals.Remove(sessionId);
            }
            
            if (sessionId == activeSessionId)
            {
                // アクティブセッションの場合は再選択
                activeSessionId = null;
                activeSession = null;
                StateHasChanged();
                await Task.Delay(100); // UIの更新を待つ
                await SelectSession(sessionId);
            }
            else
            {
                Console.WriteLine($"[OnSessionSettingsSaved] 非アクティブセッションのためターミナル再作成はスキップ");
                
                // しかし、イベントハンドラーの再登録は必要
                var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
                if (sessionInfo?.ConPtyBuffer != null)
                {
                    Console.WriteLine($"[OnSessionSettingsSaved] イベントハンドラー再登録");
                    
                    // まず既存のハンドラーをクリア
                    sessionInfo.ConPtyBuffer.ClearEventHandlers();
                    
                    // データ受信イベントハンドラー再登録
                    sessionInfo.ConPtyBuffer.DataReceived += async (data) =>
                    {
                        try
                        {
                            await ProcessReceivedData(sessionId, data);
                        }
                        catch
                        {
                            // エラー処理
                        }
                    };
                    
                    // 切断イベントハンドラー再登録
                    sessionInfo.ConPtyBuffer.Disconnected += () =>
                    {
                        Console.WriteLine($"[OnSessionSettingsSaved] セッション切断検出: {sessionId}");
                        
                        // UI更新のためInvokeAsyncを使用
                        _ = InvokeAsync(async () =>
                        {
                            // セッションがまだ存在するか確認
                            var sessionStillExists = sessions.Any(s => s.SessionId == sessionId);
                            if (sessionStillExists)
                            {
                                await RemoveSession(sessionId);
                                toast?.ShowInfo("セッションが終了しました");
                            }
                        });
                    };
                }
            }
        }
        else
        {
            StateHasChanged();
        }
        
        toast?.ShowSuccess("セッション設定を保存しました");
    }
    
    private async Task RefreshGitStatus(Guid sessionId)
    {
        var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionInfo != null && sessionInfo.IsGitRepository)
        {
            // Gitステータスを更新
            var gitInfo = await GitService.GetGitInfoAsync(sessionInfo.FolderPath);
            if (gitInfo != null)
            {
                sessionInfo.GitBranch = gitInfo.CurrentBranch;
                sessionInfo.HasUncommittedChanges = gitInfo.HasUncommittedChanges;
                sessionInfo.IsWorktree = gitInfo.IsWorktree;
                
                await LocalStorageService.SaveSessionsAsync(sessions);
                StateHasChanged();
            }
        }
    }

    private async Task RestartSessionWithoutContinue(Guid sessionId)
    {
        var sessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (sessionInfo == null)
        {
            // Session info not found
            return;
        }

        try
        {
            // Restarting session without --continue
            
            
            Console.WriteLine($"[RestartSessionWithoutContinue] セッション再起動開始: {sessionId}");
            
            // セッションを再起動（HasContinueErrorOccurredフラグにより--continueは自動的に除外される）
            var success = await SessionManager.RestartSessionAsync(sessionId);
            if (success)
            {
                Console.WriteLine($"[RestartSessionWithoutContinue] セッション再起動成功");
                
                // セッション一覧を更新
                sessions = SessionManager.GetAllSessions().ToList();
                
                // ローカルストレージに保存
                await LocalStorageService.SaveSessionsAsync(sessions);
                
                // ターミナルも削除して再作成を強制
                if (terminals.ContainsKey(sessionId))
                {
                    Console.WriteLine($"[RestartSessionWithoutContinue] 既存ターミナルを削除");
                    try
                    {
                        var terminal = terminals[sessionId];
                        await terminal.DisposeAsync();
                    }
                    catch (Exception ex) 
                    { 
                        Console.WriteLine($"[RestartSessionWithoutContinue] ターミナル破棄エラー: {ex.Message}");
                    }
                    
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("terminalFunctions.cleanupTerminal", sessionId.ToString());
                    }
                    catch (Exception ex) 
                    { 
                        Console.WriteLine($"[RestartSessionWithoutContinue] JavaScript側クリーンアップエラー: {ex.Message}");
                    }
                    terminals.Remove(sessionId);
                }
                
                // 再起動するセッションがアクティブな場合のみ再選択
                if (activeSessionId == sessionId)
                {
                    Console.WriteLine($"[RestartSessionWithoutContinue] アクティブセッションの再起動のため再選択");
                    // 強制的にセッションを再初期化するため、一旦nullにする
                    activeSessionId = null;
                    activeSession = null;
                    StateHasChanged();
                    await Task.Delay(100); // UIの更新を待つ
                    
                    // 再起動後のセッションを選択
                    await SelectSession(sessionId);
                }
                else
                {
                    Console.WriteLine($"[RestartSessionWithoutContinue] 非アクティブセッションの再起動のため再選択はスキップ");
                    // 非アクティブセッションの場合は、イベントハンドラーの再登録のみ
                    var restartedSessionInfo = sessions.FirstOrDefault(s => s.SessionId == sessionId);
                    if (restartedSessionInfo?.ConPtyBuffer != null)
                    {
                        Console.WriteLine($"[RestartSessionWithoutContinue] イベントハンドラー再登録");
                        
                        // 既存のハンドラーをクリア
                        restartedSessionInfo.ConPtyBuffer.ClearEventHandlers();
                        
                        // データ受信イベントハンドラー再登録
                        restartedSessionInfo.ConPtyBuffer.DataReceived += async (data) =>
                        {
                            try
                            {
                                await ProcessReceivedData(sessionId, data);
                            }
                            catch
                            {
                                // エラー処理
                            }
                        };
                        
                        // 切断イベントハンドラー再登録
                        restartedSessionInfo.ConPtyBuffer.Disconnected += () =>
                        {
                            Console.WriteLine($"[RestartSessionWithoutContinue] セッション切断検出: {sessionId}");
                            
                            _ = InvokeAsync(async () =>
                            {
                                var sessionStillExists = sessions.Any(s => s.SessionId == sessionId);
                                if (sessionStillExists)
                                {
                                    await RemoveSession(sessionId);
                                    toast?.ShowInfo("セッションが終了しました");
                                }
                            });
                        };
                    }
                }
                
                toast?.ShowInfo("--continueオプションなしでセッションを再起動しました");
            }
            else
            {
                // Session restart failed
                toast?.ShowError("セッション再起動に失敗しました");
            }
        }
        catch (Exception ex)
        {
            // RestartSessionWithoutContinue error
            toast?.ShowError($"セッション再起動エラー: {ex.Message}");
        }
    }
    
    public async ValueTask DisposeAsync()
    {
        // すべてのセッションのタイマーを停止
        foreach (var kvp in sessionProcessingTimers)
        {
            try
            {
                kvp.Value?.Dispose();
            }
            catch { }
        }
        sessionProcessingTimers.Clear();
        
        
        // 履歴を保存
        await SaveInputHistoryAsync();
        
        // すべてのターミナルを破棄
        foreach (var terminal in terminals.Values)
        {
            await terminal.DisposeAsync();
        }
        terminals.Clear();
        
        dotNetRef?.Dispose();
        
        // JavaScriptのイベントリスナーをクリーンアップ
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupKeyboardShortcuts");
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupDevWindowDrag");
        }
        catch (Exception)
        {
            // Dispose時のエラーは無視
        }
    }
}
