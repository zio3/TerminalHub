@namespace TerminalHub.Components.Shared
@using TerminalHub.Services
@using TerminalHub.Models
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorageService
@inject INotificationService NotificationService
@inject ISessionManager SessionManager
@implements IAsyncDisposable

@if (IsVisible)
{
    <div class="dev-window" style="@GetWindowStyle()">
        <div class="dev-window-header" @onmousedown="StartDrag" @onmouseup="StopDrag">
            <span class="dev-window-title">開発ツール</span>
            <button class="btn btn-sm btn-outline-secondary" @onclick="Close">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="dev-window-content">
            <h5>ターミナル制御テスト</h5>
            <div class="mb-3">
                <button class="btn btn-primary me-2" @onclick="ScrollToBottom">
                    <i class="bi bi-arrow-down"></i> 最下部にスクロール
                </button>
                <button class="btn btn-secondary me-2" @onclick="ScrollToTop">
                    <i class="bi bi-arrow-up"></i> 最上部にスクロール
                </button>
                <button class="btn btn-info" @onclick="GetScrollPosition">
                    <i class="bi bi-info-circle"></i> スクロール位置取得
                </button>
            </div>
            <div class="mb-3">
                <h6>スクロール情報</h6>
                <small class="text-muted">@scrollInfo</small>
            </div>
            <hr />
            <h5>通知テスト</h5>
            <div class="mb-3">
                <div class="mb-2">
                    <label class="form-label">テスト用経過時間（秒）</label>
                    <input type="number" class="form-control" @bind="testElapsedSeconds" min="1" max="300" />
                </div>
                <button class="btn btn-warning me-2" @onclick="TestBrowserNotification">
                    <i class="bi bi-bell"></i> ブラウザ通知テスト
                </button>
                <button class="btn btn-success" @onclick="TestWebHookNotification">
                    <i class="bi bi-send"></i> WebHook通知テスト
                </button>
            </div>
            <div class="mb-3">
                <h6>通知テスト結果</h6>
                <small class="text-muted">@notificationTestResult</small>
            </div>
            <hr />
            <h5>バッファダウンロード</h5>
            <div class="mb-3">
                <div class="mb-2">
                    <label class="form-label">セッション選択</label>
                    <select class="form-select" @bind="selectedSessionForDownload">
                        <option value="">-- セッションを選択 --</option>
                        @foreach (var session in GetAvailableSessions())
                        {
                            <option value="@session.SessionId">@session.GetDisplayName()</option>
                        }
                    </select>
                </div>
                <div class="mb-2">
                    <label class="form-label">ダウンロード行数（空欄で全体）</label>
                    <input type="number" class="form-control" @bind="downloadLineCount" placeholder="例: 1000" min="1" />
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary me-2" @onclick="DownloadBuffer" disabled="@(string.IsNullOrEmpty(selectedSessionForDownload))">
                        <i class="bi bi-download"></i> バッファダウンロード
                    </button>
                    <button class="btn btn-secondary" @onclick="DownloadSnapshot" disabled="@(string.IsNullOrEmpty(selectedSessionForDownload))">
                        <i class="bi bi-file-earmark-image"></i> スナップショットダウンロード
                    </button>
                </div>
            </div>
            <div class="mb-3">
                <h6>ダウンロード結果</h6>
                <small class="text-muted">@downloadResult</small>
            </div>
            <hr />
            <p class="text-muted">その他の開発ツールは後で追加します</p>
        </div>
    </div>
}

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback<bool> IsVisibleChanged { get; set; }
    
    protected override async Task OnInitializedAsync()
    {
        dotNetRef = DotNetObjectReference.Create(this);
        currentInstance = this;
        
        // LocalStorageから位置を読み込み
        var savedPosition = await LocalStorageService.GetAsync<DevWindowPosition>("devWindowPosition");
        if (savedPosition != null)
        {
            windowX = savedPosition.X;
            windowY = savedPosition.Y;
        }
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsVisible && firstRender || (IsVisible && !firstRender))
        {
            // 画面内に収まっているかチェック
            await CheckAndAdjustPosition();
        }
    }
    
    private async Task CheckAndAdjustPosition()
    {
        var windowSize = await JSRuntime.InvokeAsync<WindowSize>("terminalHubHelpers.getWindowSize");
        
        bool adjusted = false;
        
        // ウィンドウが画面外にある場合は調整
        if (windowX < 0 || windowX > windowSize.Width - 100)
        {
            windowX = 0;
            adjusted = true;
        }
        
        if (windowY < 0 || windowY > windowSize.Height - 100)
        {
            windowY = 0;
            adjusted = true;
        }
        
        if (adjusted)
        {
            StateHasChanged();
            await SavePosition();
        }
    }
    
    private bool isDragging = false;
    private double startX = 0;
    private double startY = 0;
    private double windowX = 100;
    private double windowY = 100;
    private DotNetObjectReference<DevWindow>? dotNetRef;
    private static DevWindow? currentInstance;
    private string scrollInfo = "スクロール位置情報が表示されます";
    private int testElapsedSeconds = 10;
    private string notificationTestResult = "テスト結果がここに表示されます";
    private string selectedSessionForDownload = "";
    private int? downloadLineCount = null;
    private string downloadResult = "ダウンロード結果がここに表示されます";
    
    private string GetWindowStyle()
    {
        return $"left: {windowX}px; top: {windowY}px;";
    }
    
    private async Task StartDrag(MouseEventArgs e)
    {
        isDragging = true;
        startX = e.ClientX - windowX;
        startY = e.ClientY - windowY;
        
        await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setupDevWindowDrag", dotNetRef);
    }
    
    private async Task StopDrag()
    {
        isDragging = false;
        await SavePosition();
        
        await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupDevWindowDrag");
    }
    
    [JSInvokable]
    public static void OnDevWindowMouseMove(double x, double y)
    {
        if (currentInstance != null && currentInstance.isDragging)
        {
            currentInstance.windowX = x - currentInstance.startX;
            currentInstance.windowY = y - currentInstance.startY;
            currentInstance.StateHasChanged();
        }
    }
    
    [JSInvokable]
    public static async Task OnDevWindowMouseUp()
    {
        if (currentInstance != null)
        {
            await currentInstance.StopDrag();
        }
    }
    
    private async Task SavePosition()
    {
        var position = new DevWindowPosition { X = windowX, Y = windowY };
        await LocalStorageService.SetAsync("devWindowPosition", position);
    }
    
    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                const activeTerminals = window.multiSessionTerminals;
                Object.keys(activeTerminals).forEach(sessionId => {
                    if (activeTerminals[sessionId] && activeTerminals[sessionId].terminal) {
                        activeTerminals[sessionId].terminal.scrollToBottom();
                    }
                });
            ");
            scrollInfo = $"最下部にスクロールしました - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            scrollInfo = $"エラー: {ex.Message}";
        }
    }

    private async Task ScrollToTop()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                const activeTerminals = window.multiSessionTerminals;
                Object.keys(activeTerminals).forEach(sessionId => {
                    if (activeTerminals[sessionId] && activeTerminals[sessionId].terminal) {
                        activeTerminals[sessionId].terminal.scrollToTop();
                    }
                });
            ");
            scrollInfo = $"最上部にスクロールしました - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            scrollInfo = $"エラー: {ex.Message}";
        }
    }

    private async Task GetScrollPosition()
    {
        try
        {
            var result = await JSRuntime.InvokeAsync<object>("eval", @"
                const activeTerminals = window.multiSessionTerminals;
                const positions = {};
                Object.keys(activeTerminals).forEach(sessionId => {
                    const term = activeTerminals[sessionId].terminal;
                    if (term && term.buffer && term.buffer.active) {
                        positions[sessionId] = {
                            viewportY: term.buffer.active.viewportY,
                            baseY: term.buffer.active.baseY,
                            length: term.buffer.active.length
                        };
                    }
                });
                return positions;
            ");
            scrollInfo = $"スクロール位置: {System.Text.Json.JsonSerializer.Serialize(result)} - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            scrollInfo = $"エラー: {ex.Message}";
        }
    }

    private async Task TestBrowserNotification()
    {
        try
        {
            // テスト用のSessionInfoを作成
            var testSession = new SessionInfo
            {
                SessionId = Guid.NewGuid(),
                FolderPath = "C:\\TestFolder",
                DisplayName = "通知テストセッション",
                TerminalType = TerminalType.ClaudeCode,
                ProcessingElapsedSeconds = testElapsedSeconds
            };
            
            notificationTestResult = $"ブラウザ通知を送信中... ({testElapsedSeconds}秒の処理として)";
            StateHasChanged();
            
            await NotificationService.NotifyProcessingCompleteAsync(testSession, testElapsedSeconds);
            
            notificationTestResult = $"ブラウザ通知を送信しました - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            notificationTestResult = $"エラー: {ex.Message}";
        }
    }
    
    private async Task TestWebHookNotification()
    {
        try
        {
            // テスト用のSessionInfoを作成
            var testSession = new SessionInfo
            {
                SessionId = Guid.NewGuid(),
                FolderPath = "C:\\TestFolder",
                DisplayName = "WebHookテストセッション",
                TerminalType = TerminalType.GeminiCLI,
                ProcessingElapsedSeconds = testElapsedSeconds
            };
            
            notificationTestResult = $"WebHook通知を送信中... ({testElapsedSeconds}秒の処理として)";
            StateHasChanged();
            
            // WebHookのみ送信するため、直接NotificationServiceを使用
            await NotificationService.NotifyProcessingCompleteAsync(testSession, testElapsedSeconds);
            
            notificationTestResult = $"WebHook通知を送信しました - {DateTime.Now:HH:mm:ss}\nwebhook.siteで確認してください";
        }
        catch (Exception ex)
        {
            notificationTestResult = $"エラー: {ex.Message}";
        }
    }

    private IEnumerable<SessionInfo> GetAvailableSessions()
    {
        return SessionManager.GetAllSessions();
    }
    
    private async Task DownloadBuffer()
    {
        try
        {
            if (!Guid.TryParse(selectedSessionForDownload, out var sessionId))
            {
                downloadResult = "セッションを選択してください";
                return;
            }
            
            var sessionInfo = SessionManager.GetSessionInfo(sessionId);
            if (sessionInfo?.ConPtyBuffer == null)
            {
                downloadResult = "バッファが利用できません";
                return;
            }
            
            downloadResult = "バッファデータを取得中...";
            StateHasChanged();
            
            string content;
            string filename;
            
            // バッファリングが無効化されているため、機能は利用不可
            content = "バッファリングが無効化されています。\nConPTYが画面状態を管理しているため、過去のデータは取得できません。\n\n" +
                     "この変更により、メモリ使用量が削減され、セッション切り替え時の重複問題が解決されました。";
            filename = $"buffer_disabled_{SanitizeFilename(sessionInfo.GetDisplayName())}_{DateTime.Now:yyyyMMdd_HHmmss}.txt";
            
            // ダウンロード実行
            await DownloadFile(filename, content);
            
            downloadResult = $"ダウンロード完了: {filename} ({content.Length:N0} 文字)";
        }
        catch (Exception ex)
        {
            downloadResult = $"エラー: {ex.Message}";
        }
    }
    
    private async Task DownloadSnapshot()
    {
        try
        {
            if (!Guid.TryParse(selectedSessionForDownload, out var sessionId))
            {
                downloadResult = "セッションを選択してください";
                return;
            }
            
            var sessionInfo = SessionManager.GetSessionInfo(sessionId);
            if (sessionInfo?.ConPtyBuffer == null)
            {
                downloadResult = "バッファが利用できません";
                return;
            }
            
            downloadResult = "スナップショットを取得中...";
            StateHasChanged();
            
            // バッファリングが無効化されているため、機能は利用不可
            var content = "バッファリングが無効化されています。\nConPTYが画面状態を管理しているため、スナップショットは取得できません。\n\n" +
                         "セッション切り替え時は、ConPTYが自動的に現在の画面状態を送信します。";
            var filename = $"snapshot_disabled_{SanitizeFilename(sessionInfo.GetDisplayName())}_{DateTime.Now:yyyyMMdd_HHmmss}.txt";
            
            // ダウンロード実行
            await DownloadFile(filename, content);
            
            downloadResult = $"スナップショットダウンロード完了: {filename} ({content.Length:N0} 文字)";
        }
        catch (Exception ex)
        {
            downloadResult = $"エラー: {ex.Message}";
        }
    }
    
    private async Task DownloadFile(string filename, string content)
    {
        // Base64エンコード
        var bytes = System.Text.Encoding.UTF8.GetBytes(content);
        var base64 = Convert.ToBase64String(bytes);
        
        // JavaScriptでダウンロード実行
        await JSRuntime.InvokeVoidAsync("eval", $@"
            const link = document.createElement('a');
            link.href = 'data:text/plain;charset=utf-8;base64,{base64}';
            link.download = '{filename}';
            link.click();
        ");
    }
    
    private string SanitizeFilename(string filename)
    {
        // ファイル名に使用できない文字を置換
        var invalidChars = Path.GetInvalidFileNameChars();
        var sanitized = filename;
        foreach (var c in invalidChars)
        {
            sanitized = sanitized.Replace(c, '_');
        }
        return sanitized;
    }
    
    private async Task Close()
    {
        await IsVisibleChanged.InvokeAsync(false);
    }
    
    public async ValueTask DisposeAsync()
    {
        if (isDragging)
        {
            await StopDrag();
        }
        
        dotNetRef?.Dispose();
        if (currentInstance == this)
        {
            currentInstance = null;
        }
    }
    
    private class DevWindowPosition
    {
        public double X { get; set; }
        public double Y { get; set; }
    }
    
    private class WindowSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .dev-window {
        position: fixed;
        width: 600px;
        height: 600px;
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
        z-index: 1050;
        display: flex;
        flex-direction: column;
    }
    
    .dev-window-header {
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        padding: 0.5rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        border-radius: 0.5rem 0.5rem 0 0;
    }
    
    .dev-window-title {
        font-weight: 600;
        user-select: none;
    }
    
    .dev-window-content {
        flex: 1;
        padding: 1rem;
        overflow-y: auto;
    }
</style>