@namespace TerminalHub.Components.Shared
@using TerminalHub.Services
@using TerminalHub.Models
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorageService
@inject INotificationService NotificationService
@inject ISessionManager SessionManager
@implements IAsyncDisposable

@if (IsVisible)
{
    <div class="dev-window" style="@GetWindowStyle()">
        <div class="dev-window-header" @onmousedown="StartDrag" @onmouseup="StopDrag">
            <span class="dev-window-title">開発ツール</span>
            <button class="btn btn-sm btn-outline-secondary" @onclick="Close">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="dev-window-content">
            <h5>ターミナル制御テスト</h5>
            <div class="mb-3">
                <button class="btn btn-primary me-2" @onclick="ScrollToBottom">
                    <i class="bi bi-arrow-down"></i> 最下部にスクロール
                </button>
                <button class="btn btn-secondary me-2" @onclick="ScrollToTop">
                    <i class="bi bi-arrow-up"></i> 最上部にスクロール
                </button>
                <button class="btn btn-info" @onclick="GetScrollPosition">
                    <i class="bi bi-info-circle"></i> スクロール位置取得
                </button>
            </div>
            <div class="mb-3">
                <h6>スクロール情報</h6>
                <small class="text-muted">@scrollInfo</small>
            </div>
            <hr />
            <h5>通知テスト</h5>
            <div class="mb-3">
                <div class="mb-2">
                    <label class="form-label">テスト用経過時間（秒）</label>
                    <input type="number" class="form-control" @bind="testElapsedSeconds" min="1" max="300" />
                </div>
                <button class="btn btn-warning me-2" @onclick="TestBrowserNotification">
                    <i class="bi bi-bell"></i> ブラウザ通知テスト
                </button>
                <button class="btn btn-success" @onclick="TestWebHookNotification">
                    <i class="bi bi-send"></i> WebHook通知テスト
                </button>
            </div>
            <div class="mb-3">
                <h6>通知テスト結果</h6>
                <small class="text-muted">@notificationTestResult</small>
            </div>
            <hr />
            <h5>バッファダウンロード</h5>
            <div class="mb-3">
                <div class="mb-2">
                    <label class="form-label">セッション選択</label>
                    <select class="form-select" @bind="selectedSessionForDownload">
                        <option value="">-- セッションを選択 --</option>
                        @foreach (var session in GetAvailableSessions())
                        {
                            <option value="@session.SessionId">@session.GetDisplayName()</option>
                        }
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary me-2" @onclick="DownloadBuffer" disabled="@(string.IsNullOrEmpty(selectedSessionForDownload))">
                        <i class="bi bi-download"></i> バッファダウンロード
                    </button>
                </div>
            </div>
            <div class="mb-3">
                <h6>ダウンロード結果</h6>
                <small class="text-muted">@downloadResult</small>
            </div>
            <hr />
            <h5>診断情報</h5>
            <div class="mb-3">
                <button class="btn btn-info me-2" @onclick="RefreshDiagnostics">
                    <i class="bi bi-arrow-clockwise"></i> 診断情報を更新
                </button>
                <button class="btn btn-warning" @onclick="RunJSDiagnostics">
                    <i class="bi bi-bug"></i> JS診断実行
                </button>
            </div>
            <div class="mb-3">
                <h6>セッション一覧</h6>
                <div class="table-responsive">
                    <table class="table table-sm table-striped">
                        <thead>
                            <tr>
                                <th>SessionId</th>
                                <th>状態</th>
                                <th>名前</th>
                                <th>Terminal</th>
                                <th>ConPTY</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (diagnosticSessions != null)
                            {
                                @foreach (var session in diagnosticSessions)
                                {
                                    <tr>
                                        <td class="text-truncate" style="max-width: 200px;" title="@session.SessionId">@session.SessionId</td>
                                        <td>@(session.IsActive ? "Active" : "Inactive")</td>
                                        <td>@session.GetDisplayName()</td>
                                        <td>
                                            @if (TerminalsDict != null && TerminalsDict.ContainsKey(session.SessionId))
                                            {
                                                <span class="badge bg-success">有</span>
                                            }
                                            else
                                            {
                                                <span class="badge bg-danger">無</span>
                                            }
                                        </td>
                                        <td>
                                            @if (session.ConPtySession != null)
                                            {
                                                <span class="badge bg-primary">有</span>
                                            }
                                            else
                                            {
                                                <span class="badge bg-warning">無</span>
                                            }
                                        </td>
                                    </tr>
                                }
                            }
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="mb-3">
                <h6>ターミナル一覧</h6>
                <p>JavaScript側ターミナル数: <span class="badge bg-info">@jsTerminalCount</span></p>
                <p>C#側ターミナル辞書数: <span class="badge bg-info">@(TerminalsDict?.Count ?? 0)</span></p>
            </div>
            <hr />
            <p class="text-muted">その他の開発ツールは後で追加します</p>
        </div>
    </div>
}

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback<bool> IsVisibleChanged { get; set; }
    
    protected override Task OnInitializedAsync()
    {
        dotNetRef = DotNetObjectReference.Create(this);
        currentInstance = this;
        
        // JavaScript interopはOnAfterRenderAsyncで実行
        return Task.CompletedTask;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // LocalStorageから位置を読み込み
            var savedPosition = await LocalStorageService.GetAsync<DevWindowPosition>("devWindowPosition");
            if (savedPosition != null)
            {
                windowX = savedPosition.X;
                windowY = savedPosition.Y;
                StateHasChanged();
            }
        }
        
        if (IsVisible && firstRender || (IsVisible && !firstRender))
        {
            // 画面内に収まっているかチェック
            await CheckAndAdjustPosition();
        }
    }
    
    private async Task CheckAndAdjustPosition()
    {
        var windowSize = await JSRuntime.InvokeAsync<WindowSize>("terminalHubHelpers.getWindowSize");
        
        bool adjusted = false;
        
        // ウィンドウが画面外にある場合は調整
        if (windowX < 0 || windowX > windowSize.Width - 100)
        {
            windowX = 0;
            adjusted = true;
        }
        
        if (windowY < 0 || windowY > windowSize.Height - 100)
        {
            windowY = 0;
            adjusted = true;
        }
        
        if (adjusted)
        {
            StateHasChanged();
            await SavePosition();
        }
    }
    
    private bool isDragging = false;
    private double startX = 0;
    private double startY = 0;
    private double windowX = 100;
    private double windowY = 100;
    private DotNetObjectReference<DevWindow>? dotNetRef;
    private static DevWindow? currentInstance;
    private string scrollInfo = "スクロール位置情報が表示されます";
    private int testElapsedSeconds = 10;
    private string notificationTestResult = "テスト結果がここに表示されます";
    private string selectedSessionForDownload = "";
    private string downloadResult = "ダウンロード結果がここに表示されます";
    
    // 診断情報用
    private List<SessionInfo>? diagnosticSessions;
    private Dictionary<Guid, IJSObjectReference>? TerminalsDict;
    private int jsTerminalCount = 0;
    
    private string GetWindowStyle()
    {
        return $"left: {windowX}px; top: {windowY}px;";
    }
    
    private async Task StartDrag(MouseEventArgs e)
    {
        isDragging = true;
        startX = e.ClientX - windowX;
        startY = e.ClientY - windowY;
        
        await JSRuntime.InvokeVoidAsync("terminalHubHelpers.setupDevWindowDrag", dotNetRef);
    }
    
    private async Task StopDrag()
    {
        isDragging = false;
        await SavePosition();
        
        await JSRuntime.InvokeVoidAsync("terminalHubHelpers.cleanupDevWindowDrag");
    }
    
    [JSInvokable]
    public static void OnDevWindowMouseMove(double x, double y)
    {
        if (currentInstance != null && currentInstance.isDragging)
        {
            currentInstance.windowX = x - currentInstance.startX;
            currentInstance.windowY = y - currentInstance.startY;
            currentInstance.StateHasChanged();
        }
    }
    
    [JSInvokable]
    public static async Task OnDevWindowMouseUp()
    {
        if (currentInstance != null)
        {
            await currentInstance.StopDrag();
        }
    }
    
    private async Task SavePosition()
    {
        var position = new DevWindowPosition { X = windowX, Y = windowY };
        await LocalStorageService.SetAsync("devWindowPosition", position);
    }
    
    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                const activeTerminals = window.multiSessionTerminals;
                Object.keys(activeTerminals).forEach(sessionId => {
                    if (activeTerminals[sessionId] && activeTerminals[sessionId].terminal) {
                        activeTerminals[sessionId].terminal.scrollToBottom();
                    }
                });
            ");
            scrollInfo = $"最下部にスクロールしました - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            scrollInfo = $"エラー: {ex.Message}";
        }
    }

    private async Task ScrollToTop()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                const activeTerminals = window.multiSessionTerminals;
                Object.keys(activeTerminals).forEach(sessionId => {
                    if (activeTerminals[sessionId] && activeTerminals[sessionId].terminal) {
                        activeTerminals[sessionId].terminal.scrollToTop();
                    }
                });
            ");
            scrollInfo = $"最上部にスクロールしました - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            scrollInfo = $"エラー: {ex.Message}";
        }
    }

    private async Task GetScrollPosition()
    {
        try
        {
            var result = await JSRuntime.InvokeAsync<object>("eval", @"
                const activeTerminals = window.multiSessionTerminals;
                const positions = {};
                Object.keys(activeTerminals).forEach(sessionId => {
                    const term = activeTerminals[sessionId].terminal;
                    if (term && term.buffer && term.buffer.active) {
                        positions[sessionId] = {
                            viewportY: term.buffer.active.viewportY,
                            baseY: term.buffer.active.baseY,
                            length: term.buffer.active.length
                        };
                    }
                });
                return positions;
            ");
            scrollInfo = $"スクロール位置: {System.Text.Json.JsonSerializer.Serialize(result)} - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            scrollInfo = $"エラー: {ex.Message}";
        }
    }

    private async Task TestBrowserNotification()
    {
        try
        {
            // テスト用のSessionInfoを作成
            var testSession = new SessionInfo
            {
                SessionId = Guid.NewGuid(),
                FolderPath = "C:\\TestFolder",
                DisplayName = "通知テストセッション",
                TerminalType = TerminalType.ClaudeCode,
                ProcessingElapsedSeconds = testElapsedSeconds
            };
            
            notificationTestResult = $"ブラウザ通知を送信中... ({testElapsedSeconds}秒の処理として)";
            StateHasChanged();
            
            await NotificationService.NotifyProcessingCompleteAsync(testSession, testElapsedSeconds);
            
            notificationTestResult = $"ブラウザ通知を送信しました - {DateTime.Now:HH:mm:ss}";
        }
        catch (Exception ex)
        {
            notificationTestResult = $"エラー: {ex.Message}";
        }
    }
    
    private async Task TestWebHookNotification()
    {
        try
        {
            // テスト用のSessionInfoを作成
            var testSession = new SessionInfo
            {
                SessionId = Guid.NewGuid(),
                FolderPath = "C:\\TestFolder",
                DisplayName = "WebHookテストセッション",
                TerminalType = TerminalType.GeminiCLI,
                ProcessingElapsedSeconds = testElapsedSeconds
            };
            
            notificationTestResult = $"WebHook通知を送信中... ({testElapsedSeconds}秒の処理として)";
            StateHasChanged();
            
            // WebHookのみ送信するため、直接NotificationServiceを使用
            await NotificationService.NotifyProcessingCompleteAsync(testSession, testElapsedSeconds);
            
            notificationTestResult = $"WebHook通知を送信しました - {DateTime.Now:HH:mm:ss}\nwebhook.siteで確認してください";
        }
        catch (Exception ex)
        {
            notificationTestResult = $"エラー: {ex.Message}";
        }
    }

    private IEnumerable<SessionInfo> GetAvailableSessions()
    {
        return SessionManager.GetAllSessions();
    }
    
    private async Task RefreshDiagnostics()
    {
        try
        {
            // セッション一覧を取得
            diagnosticSessions = SessionManager.GetAllSessions().ToList();
            
            // JavaScript側のターミナル数を取得
            jsTerminalCount = await JSRuntime.InvokeAsync<int>("terminalHubHelpers.getTerminalCount");
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DevWindow] 診断情報取得エラー: {ex.Message}");
        }
    }
    
    public void SetTerminalsDict(Dictionary<Guid, IJSObjectReference> terminals)
    {
        TerminalsDict = terminals;
        StateHasChanged();
    }
    
    private async Task RunJSDiagnostics()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("terminalHubHelpers.diagnoseTerminals");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DevWindow] JS診断エラー: {ex.Message}");
        }
    }
    
    private async Task DownloadBuffer()
    {
        try
        {
            if (!Guid.TryParse(selectedSessionForDownload, out var sessionId))
            {
                downloadResult = "セッションを選択してください";
                return;
            }
            
            var sessionInfo = SessionManager.GetSessionInfo(sessionId);
            if (sessionInfo?.ConPtySession == null)
            {
                downloadResult = "ConPtySessionが利用できません";
                return;
            }
            
            downloadResult = "バッファデータを取得中...";
            StateHasChanged();
            
            string content;
            string filename;
            
            // ConPtySessionではバッファ取得機能はサポートされていません
            content = "ConPtySessionではバッファ取得機能はサポートされていません";
            
            if (string.IsNullOrEmpty(content))
            {
                content = "バッファが空です。";
            }
            
            var bufferInfo = new
            {
                Status = "Enabled",
                BufferSize = content.Length,
                LineCount = content.Split('\n').Length,
                TerminalSize = $"{sessionInfo.ConPtySession.Cols}x{sessionInfo.ConPtySession.Rows}",
                SessionId = sessionId
            };
            
            content = "--- バッファ情報 ---\n" + System.Text.Json.JsonSerializer.Serialize(bufferInfo, new System.Text.Json.JsonSerializerOptions { WriteIndented = true }) + "\n\n--- バッファ内容 ---\n" + content;
            filename = $"buffer_{SanitizeFilename(sessionInfo.GetDisplayName())}_{DateTime.Now:yyyyMMdd_HHmmss}.txt";
            
            // ダウンロード実行
            await DownloadFile(filename, content);
            
            downloadResult = $"ダウンロード完了: {filename} ({content.Length:N0} 文字)";
        }
        catch (Exception ex)
        {
            downloadResult = $"エラー: {ex.Message}";
        }
    }
    
    
    private async Task DownloadFile(string filename, string content)
    {
        // Base64エンコード
        var bytes = System.Text.Encoding.UTF8.GetBytes(content);
        var base64 = Convert.ToBase64String(bytes);
        
        // JavaScriptでダウンロード実行
        await JSRuntime.InvokeVoidAsync("eval", $@"
            const link = document.createElement('a');
            link.href = 'data:text/plain;charset=utf-8;base64,{base64}';
            link.download = '{filename}';
            link.click();
        ");
    }
    
    private string SanitizeFilename(string filename)
    {
        // ファイル名に使用できない文字を置換
        var invalidChars = Path.GetInvalidFileNameChars();
        var sanitized = filename;
        foreach (var c in invalidChars)
        {
            sanitized = sanitized.Replace(c, '_');
        }
        return sanitized;
    }
    
    private async Task Close()
    {
        await IsVisibleChanged.InvokeAsync(false);
    }
    
    public async ValueTask DisposeAsync()
    {
        if (isDragging)
        {
            await StopDrag();
        }
        
        dotNetRef?.Dispose();
        if (currentInstance == this)
        {
            currentInstance = null;
        }
    }
    
    private class DevWindowPosition
    {
        public double X { get; set; }
        public double Y { get; set; }
    }
    
    private class WindowSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .dev-window {
        position: fixed;
        width: 600px;
        height: 600px;
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
        z-index: 1050;
        display: flex;
        flex-direction: column;
    }
    
    .dev-window-header {
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        padding: 0.5rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        border-radius: 0.5rem 0.5rem 0 0;
    }
    
    .dev-window-title {
        font-weight: 600;
        user-select: none;
    }
    
    .dev-window-content {
        flex: 1;
        padding: 1rem;
        overflow-y: auto;
    }
</style>